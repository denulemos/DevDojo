<div align="center">

# DevDojo

![Dev GIF](https://i.pinimg.com/originals/a7/a8/d0/a7a8d06c754cfbbbc37e64cb118c513c.gif)

</div>

Preguntas son agregadas todas las semanas. Se aceptan sugerencias mediante Pull Request!

## Tabla de Temas (Sigue en desarrollo y re-organizaci√≥n)

- [Preguntas mas comunes en entrevistas de trabajo para un FE Engineer](./PreguntasComunes.md)

- [Algoritmos y manejo de datos](./Algoritmos.md)
  - [Programaci√≥n Funcional y Orientada a Objetos](#alg-base-obj)
  - [Manejo de Eventos y Asincron√≠a](#alg-base-async)
  - [Estructuras Avanzadas y Generics](#alg-base-3)
  - [Buenas Pr√°cticas y Casos Comunes](#alg-base-4)
- [Organizacion en Software - Derecho en IT](./Organizacion.md)
- [Typescript - Javascript](./JSTS.md)
- [Javascript Frameworks y Librerias](#rea-base)
  - [HTML - CSS - SCSS](./html.md)
  - [React](./react.md)
  - [Angular](./Angular.md)
  - [Conceptos Generales](#fe-base)
- [Desarrollo Mobile y React Native](./DesarrolloMobile.md)
- [QA](./QA.md)
- [Control de Versiones y Cambios](./Versionado.md)
- [Conceptos Codigo Limpio, Objetos y Dise√±o](#cod-base)
- [Hardware, Sistemas, Infraestructura y Arquitectura](./Hardware.md)
- [Bases de Datos](./BaseDatos.md)
- [Seguridad](./Seguridad.md)
- [Accesibilidad](./Accesibilidad.md)

<a name="alg-base-obj"></a>

| Programaci√≥n Funcional y Orientada a Objetos |
|----------|
| [Que es la programacion funcional?](#var27-1) üíõ |
| [¬øQu√© es una funcion Declarativa y una Expresiva?](#var35) |
| [Diferencia entre primitivo y objeto](#var14) |
| [Variable Hoisting](#var24) üíõ |
| [Diferencia entre class y function](#var25) |
| [Que es el Function Factory?](#var20) |
| [Que es el Currying?](#var23)  üíõ |
| [¬øQu√© son las funciones puras y c√≥mo se relacionan con la programaci√≥n funcional?](#var23-1)|

<a name="alg-base-async"></a>

| Manejo de Eventos y Asincron√≠a |
|----------|
| [Event delegation](#var11) |
| [Bubble vs Capture](#var15) |
| [Funciones de "bloqueo" y "no bloqueo"](#var13) |
| [¬øC√≥mo manejar√≠as errores en funciones con async/await de forma eficiente?](#var10-4) üíõ|
|[¬øC√≥mo implementar√≠as un patr√≥n pub/sub para manejar eventos entre diferentes partes de una aplicaci√≥n?](#var10-5)|


<a name="alg-base-4"></a>

| Buenas Pr√°cticas y Casos Comunes |
|----------|
| [Porque no se recomienda usar innerHTML?](#var33) |
| [Entre JS y un script ASP, ¬øCual es mas r√°pido?](#var34) |
| [Qu√© es una variable global, como se declara y cuales problemas puede tener?](#var31) |

<a name="rea-base"></a>

## [Javascript Frameworks y Librerias](#rea)

<a name="fe-base"></a>

| Conceptos Generales |
|----------|
| [¬øDe qu√© hablamos cuando hablamos de una SPA (Single Page App)?](#rea48) üíõ|
| [Como evitar mandar muchos eventos inutiles, por ejemplo, ejecutar un search por letra?](#rea50) üíõ|
| [Que es async rendering?](#rea51) üíõ|
| [Para que son los eventos sinteticos (SyntheticEvent)?](#rea53) |
| [Que significa prop drilling y como evitarlo?](#rea54) |
| [Como puedo mejorar la performance de mi Frontend?](#rea17) üíõ|
| [¬øQue es async, preload y prefetch?](#rea29) |
| [Cual es la diferencia entre call, bind y apply?](#rea30) |
| [Qu√© es "REPL" y para qu√© sirve?](#rea32) |
| [Qu√© es el "demultiplexer"?](#rea33) |
| [Que hace Babel?](#rea34) |
| [Que hace Webpack?](#rea35) |
| [Que es el server side rendering?](#rea36) |
| [Que es Tree Shaking?](#rea37) |
| [¬øQue es el SEO?](#rea38) |
| [Que es la tipificacion de Variables?](#rea41) |
| [Concepto Truthy and Falsy](#rea42) |
| [Que es la Coercion explicita e Implicita?](#rea44) |
| [Que es la expresion de Funcion Inmediatamente Invocada - Immediatelyinvoked Function Expression (IIFE)?](#rea49) |
| [Qu√© es un Event listener?](#rea50) |
| [isNaN vs Math.isNaN](#rea51) |
| [Que es Symbol?](#rea52) |
| [Cual es la diferencia entre un event loop, microtask y macrotask?](#rea53) |
| [Variable Shadowing - Ocultamiento de Variables](#rea54) |

<a name="cod-base"></a>

## [Conceptos Codigo Limpio, Objetos y Dise√±o](#cod)

| Temas |
|----------|
| [Ejemplo de Pseudo-c√≥digo](#diag1) |
| [Diagramas de Nassi-Schneiderman](#diag2) |
| [¬øDe qu√© trata el c√≥digo limpio?](#cod1) |
| [Nombres Significativos en Codigo Limpio](#cod2) |
| [Concepto DRY](#cod5) |
| [Concepto KISS](#cod6) |
| [Concepto YAGNI](#cod7) |
| [Concepto LOD](#cod8) |
| [Funciones Limpias](#cod9) |
| [Unico Nivel de abstraccion](#cod10) |
| [Manejo limpio de Parametros](#cod11) |
| [Cuales son los beneficios de una Code Review?](#cod12) |
| [Que tipos de Code review existen?](#cod13) |
| [Domain Driven Design](#cod14) |
| [¬øQu√© es un patr√≥n de dise√±o?](#cod15) |
| [En qu√© se inspiran los patrones de dise√±o?](#cod16) |
| [¬øQu√© se obtiene con la implementaci√≥n de patrones de dise√±o?](#cod17) |
| [¬øPara qu√© sirven los patrones de dise√±o?](#cod18) |
| [¬øCu√°les son los elementos de un patr√≥n de dise√±o?](#cod19) |
| [¬øCu√°les son los tipos de patrones de dise√±o?](#cod20) |
| [¬øQu√© es la intenci√≥n y motivaci√≥n de un patr√≥n de dise√±o?](#cod21) |
| [¬øQu√© es la aplicabilidad de un patr√≥n de dise√±o?](#cod22) |
| [¬øQu√© es la estructura de un patr√≥n de dise√±o?](#cod23) |
| [¬øQui√©nes son los participantes de un patr√≥n de dise√±o?](#cod24) |
| [Patrones Estructurales](#cod25) |
| [Patrones Creacionales](#cod26) |
| [Patrones Comportamiento](#cod27) |
| [Excepciones en lugar de codigos de error](#cod28) |
| [Manejo de Comentarios en el codigo](#cod29) |
| [Acomplamiento artificial](#cod30) |
| [Unchecked Exceptions](#cod31) |
| [Excepciones en lugar de c√≥digos de error](#cod32) |
| [Gesti√≥n de errores](#cod33) |
| [Indentaci√≥n](#cod34) |
| [C√≥digo en el nivel de abstracci√≥n incorrecto](#cod35) |
| [Acoplamiento (Evitar)](#cod36) |
| [Cohesion (Fomentar)](#cod37) |
| [Uso de numeros magicos en lugar de constantes](#cod38) |
| [Qu√© es la Programaci√≥n orientada a Objetos?](#cod39) |
| [Qu√© es la programaci√≥n procedural?](#cod40) |
| [Qu√© es la programacion declarativa?](#cod41) |
| [Que es la Programacion Imperativa?](#cod42) |
| [Qu√© es la Programacion Estructurada?](#cod43) |
| [Que es un antipatron?](#cod44) |
| [Que tipos de antipatrones para el dise√±o de Software existen?](#cod45) |
| [Que tipos de Antipatrones para el Dise√±o Orientado a Objetos existen?](#cod46) |
| [Singleton](#cod47) |
| [Que es el Polimorfismo?](#cod48) |
| [Que es el Upcasting?](#cod49) |
| [Que es el Downcasting?](#cod50) |
| [¬øC√≥mo se produce la ligadura tard√≠a y din√°mica que posibilita el polimorfismo?](#cod51) |
| [El Principio de Sustituci√≥n de Liskov](#cod52) |
| [¬øC√≥mo ejemplificar√≠as el uso de polimorfismo en Java usando una colecci√≥n de objetos?](#cod53) |
| [Qu√© es la densidad de codigo?](#cod54) |
| [La importancia del orden de las funciones](#cod55) |
| [Porque se deberia evitar retornar null?](#cod56) |
| [Porque se deberia evitar el uso de variables globales?](#cod57) |
|[¬øC√≥mo podr√≠as mejorar la calidad del c√≥digo en un proyecto en marcha?](#cod57-1)|
|[Si tienes plazos ajustados y te ves obligado a escribir "mal c√≥digo", ¬øc√≥mo manejar√≠as esa situaci√≥n?](#cod57-2) |

| Code Smells |
|----------|
| [¬øQu√© es un Code Smell?](#cod58) |
| [Code Smells en los Tests](#cod59) |
| [Code Smells en Codigo](#cod60) |
| [Code Smells en Nombres](#cod61) |
| [Code Smells en Comentarios](#cod62) |
| [Code Smells en el entorno](#cod63) |
| [Code Smells en Funciones](#cod64) |

| SOLID |
|----------|
| [Concepto SOLID](#cod4) |
| [Dependency Inversion Principle](#cod3) |
| [Single Responsibility Principle](#cod65) |
| [Open/Closed Principle](#cod66) |
| [Interface Segregation Principle](#cod67) |
| [Liskov Substitution Principle](#cod68) |

---

<a id="var27-1"></a>

### **Que es la programacion funcional?** üíõ

[Volver al indice](#alg-base-obj)

Es un paradigma de programaci√≥n que trata de minimizar los cambios de estado y los datos mutables. Se basa en funciones puras, que son funciones que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos.

```jsx
const sum = (a, b) => a + b;
```

La programaci√≥n funcional se basa en los siguientes principios:

- **Inmutabilidad**: Los datos no cambian una vez que se han creado.
- **Funciones puras**: Las funciones no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos.
- **Composici√≥n de funciones**: Las funciones se pueden combinar para crear funciones m√°s complejas.
- **Declaratividad**: Se centra en qu√© se quiere hacer, no en c√≥mo hacerlo.
- **Transparencia referencial**: Dado un valor de entrada, la funci√≥n siempre devolver√° el mismo valor de salida.
- **Recursi√≥n**: Se pueden definir funciones que se llaman a s√≠ mismas para resolver problemas de manera iterativa.
- **Funciones de orden superior**: Las funciones pueden tomar otras funciones como argumentos o devolver funciones como resultado.
- **Evaluaci√≥n perezosa**: Los valores se calculan solo cuando se necesitan.
- **Currying**: Transformar una funci√≥n que toma varios argumentos en una secuencia de funciones que toman un solo argumento.

<a id="var35"></a>

### **¬øQu√© es una funcion Declarativa y una Expresiva?**

[Volver al indice](#alg-base-obj)

En las **Funciones Declarativas** usamos la palabra reservada `Function` para poder declararla

```jsx
 function saludar(nombre) {
  console.log(`Hola ${nombre}`);
}

saludar('Diego');
```

La **Expresiva (Expresion de Funcion)** es cuando la declaramos tipo variable como funcion anonima

```jsx
var nombre = function(nombre){
    console.log(`Hola ${nombre}`)
}

nombre(‚ÄòDiego‚Äô);
```

A las funciones declarativas se les aplica hoisting, a la otra no, hoisting se aplica solo a las palabra sreservadas `var` y `function`, es decir, a la expresion de funcion podriamos llamarla recien despues de declararla.


<a id="var14"></a>

### **Diferencia entre primitivo y objeto**

[Volver al indice](#alg-base-obj)

- Los primitivos se pasan por valor, los objetos se pasan por referencia
- Los primitivos se copian por valor y los objetos se copian por referencia
- Los primitivos se comparan por valor y los objetos por referencia
- Los primitivos son inmutables, el unico elemento inmutable del objeto es su referencia, el valor puede ser modificado.

Casos **primitivos**

```jsx
let animal = ‚Äòperro‚Äô
let mascota = animal
animal = 'gato'
console.log(mascota) // perro, se copio por valor y no referencia
```

Caso **objetos** ( Como puedo clonar un objeto ?)

```jsx
let animal = {
  nombre: 'perro'
}

let mascota = animal
animal.especie = 'gato'
console.log(mascota.nombre) // gato, se copio referencia no valor

---

let object = {a: 1, b:2};
let referencia = object; // Esto es solo una referencia

let clone = {...object}; // Esto si es un clon
let clone2 = Object.assign({}, object);// Esto si es un clon

clone.foo = "foo";
clone2.foo = "denu";

console.log(object);// { a: 1, b: 2 }
console.log(referencia); // { a: 1, b: 2 }
console.log(clone); // { a: 1, b: 2, foo: 'foo' }
```

<a id="var24"></a>

### **Variable Hoisting** üíõ

[Volver al indice](#alg-base-obj)

Es un mecanismo de JS en el que las variables y declaraciones de funciones se mueven a la parte superior de su ambito antes de la ejecucion del codigo.

```jsx
console.log (saludar);
    var saludar = "dice hola"

// es decir

var saludar;
    console.log(saludar); // saludar is undefined
    saludar = "dice hola"
```

Es el usar las variables antes de que sean declaradas.

<a id="var25"></a>

### **Diferencia entre class y function**

[Volver al indice](#alg-base-obj)

class tiene un alcance comprendido por llaves, al igual que las variables let. function es local a la funcion donde fue definida, no podemos usar una clase o funcion constructora por fuera del alcance en donde se encuentra.

```jsx
// Class
{
  class C {
  }
}

// Function
function x () {
  function C () {
  }
}

// uso de ambas
try {
  const obj = new C();
  console.assert( false );
} catch (err) {
  console.assert(
    err.message === 'C is not defined'
  );
}
```

Ambas pueden ser definidas de forma anonima. Sus referencias funcionan igual que con object, no se envia una copia, si no una referencia de la misma.

```jsx
const C = class {};
const C = function () {};

console.assert( typeof  C === 'function' );
```

<a id="var20"></a>

### **Que es el Function Factory?**

[Volver al indice](#alg-base-obj)

Son funciones que crean funciones u objetos. Con este patron se puede implementar Currying

```jsx
const crearUsuario = ({ userName, avatar }) => ({
      id: crearUnID(),
      userName,
      avatar,
      cambiarUserName (userName) {
        this.userName = userName;
        return this;
      },
      cambiarAvatar (url) {
        // ejecuta logica para obtener el avatar desde la url
        const nuevoAvatar = obtenerAvtarDesdeUrl(url)
        this.avatar = nuevoAvatar
        return this
      }
    });

        console.log(crearUsuario({ userName: 'Bender', avatar: 'bender.png' }));

    {
      "id":"17hakg9a7jas",
      "avatar": "bender.png",
      "userName": "Bender",
      "cambiarUsername": [Function cambiarUsername]
      "cambiarAvatar": [Function cambiarAvatar]

    }
    */
```

<a id="var23"></a>

### **Que es el Currying?** üíõ

[Volver al indice](#alg-base-obj)

Es una t√©cnica de programaci√≥n funcional que consiste en transformar una funci√≥n que recibe m√∫ltiples argumentos en una secuencia de funciones que reciben un solo argumento.

```jsx
function add(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}
add(10)(20)(30); // 60
```

<a id="var23-1"></a>

### **¬øQu√© son las funciones puras y c√≥mo se relacionan con la programaci√≥n funcional?**

[Volver al indice](#alg-base-obj)

Las funciones puras son funciones que siempre devuelven el mismo resultado dadas los mismos parametros, no dependen de factores externos como states o variables.

```jsx
function suma (a, b) {
  return a + b;
}

function agregarElemento(array, elemento) {
  return [...array, elemento]; // Crea un nuevo array sin modificar el original
}

const miArray = [1, 2, 3];
const nuevoArray = agregarElemento(miArray, 4);

console.log(miArray);      // [1, 2, 3] (el array original no se modifica)
console.log(nuevoArray);   // [1, 2, 3, 4]

```

Una funcion que no es pura se puede ver asi:

```jsx
let contador = 0;

function incrementar(a) {
  contador++; // Modifica el estado externo
  return a + contador;
}
```

Si utilizas funciones puras, puedes:

- Evitar errores al no modificar datos globales ni estados externos.
- Hacer pruebas unitarias f√°cilmente, porque su comportamiento es predecible.
- Aprovechar caracter√≠sticas como la memoizaci√≥n, donde puedes guardar los resultados de funciones puras y reutilizarlos para optimizaci√≥n.

---

<a id="var11"></a>

### **Event delegation**

[Volver al indice](#alg-base-async)

Por ejemplo, si tenemos botones y queremos hacer eventos para todos los botones, no es viable hacer un evento por boton ya que no es escalable.

Agregamos el evento al container y dependiendo donde es el click (en cual boton), se detecta una cierta clase o propiedad, y se ejecuta el evento correspondiente utilizando [`e.target`](http://e.target) para identificar el elemento, por ejemplo.

<a id="var15"></a>

### **Bubble vs Capture**

[Volver al indice](#alg-base-async)

Cuando agregamos un elemento parece que solo lo agregamos a un elemento DOM pero en realidad este se propaga en una direccion. Podemos elegir cual direccion escuchan nuestros eventos.

- Fase Capture: Llega al evento que dispara el evento
- Fase Target
- Fase Bubbling

<a id="var13"></a>

### **Funciones de "bloqueo" y "no bloqueo"**

[Volver al indice](#alg-base-async)

Cuando emites una¬†funci√≥n de bloqueo,¬†las dem√°s piezas de c√≥digo detienen su ejecuci√≥n hasta que haya sido completado un evento designado de Entrada/Salida.

A su vez, las¬†funciones de no bloqueo le permiten al desarrollador realizar m√∫ltiples tareas (Manteniendo m√∫ltiples c√≥digos en ejecuci√≥n) mientras que simult√°neamente se realizan m√∫ltiples eventos de Entrada/Salida.

<a id="var10-4"></a>

### **¬øC√≥mo manejar√≠as errores en funciones con async/await de forma eficiente?**

[Volver al indice](#alg-base-async)

Para manejar errores en funciones con async/await de forma eficiente, se puede usar un bloque `try/catch` para manejar errores de manera sincrona.

```jsx
async function myAsyncFunction() {
  try {
    const value = await promise;
    console.log(value);
  } catch (error) {
    console.error(error);
  }
}
```

<a id="var10-5"></a>

### **¬øC√≥mo implementar√≠as un patr√≥n pub/sub para manejar eventos entre diferentes partes de una aplicaci√≥n?**

[Volver al indice](#alg-base-async)

El patr√≥n pub/sub (publicaci√≥n/suscripci√≥n) es un patr√≥n de dise√±o de software que permite la comunicaci√≥n entre diferentes partes de una aplicaci√≥n.

```jsx
// Implementaci√≥n de un patr√≥n pub/sub
const pubsub = (function() {
  const events = {};

  // Suscribirse a un evento
  function subscribe(eventName, fn) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(fn);
  }

  // Publicar un evento
  function publish(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach((fn) => {
        fn(data);
      });
    }
  }

  return {
    subscribe,
    publish
  };
})();

// Uso del patr√≥n pub/sub
function mySubscriber(data) {
  console.log(data);
}

// Suscribirse a un evento
pubsub.subscribe('event1', mySubscriber); // Suscribirse a 'event1'
pubsub.publish('event1', 'hello, world!'); // Publicar 'event1'

// Salida: 'hello, world!'
```

---

<a id="var31"></a>

### **Qu√© es una variable global, como se declara y cuales problemas puede tener?**

[Volver al indice](#alg-base)

Se pueden usar en todo el codigo, no tienen alcance. Se declara sin usar `var` en la declaracion

```jsx
miVariableGlobal = 'Hola mundo'
```

Puede dar al choque entre variables locales y globales por nombre. Ademas es dificil limpiar el codigo basado en variables globales

<a id="var33"></a>

### **Porque no se recomienda usar innerHTML?**

[Volver al indice](#alg-base)

No se recomienda su uso porque es muy lento dado que refresca el contenido cada vez. Es m√°s f√°cil insertar un c√≥digo errado en el documento y hacer que la p√°gina web sea inestable.

<a id="var34"></a>

### **Entre JS y un script ASP, ¬øCual es mas r√°pido?**

[Volver al indice](#alg-base)

JavaScript es m√°s r√°pido porque es un lenguaje del lado del cliente y no necesita la ayuda del servidor web para ejecutarse. Por otra parte el ASP es un lenguaje del lado del servidor. Motivo por el que siempre es m√°s lento que JavaScript. Sin embargo, Javascript ahora, tambi√©n puede ser usado como un lenguaje de lado del servidor (server side) (nodejs).

---

<a id="cic67"></a>

### **Imagina que un cliente te dice que la aplicaci√≥n es lenta y quiere que la aceleres, pero no te da m√°s detalles. ¬øC√≥mo manejar√≠as esta situaci√≥n?** üíõ

[Volver al indice](#cic-base-2)

**Entender el Problema**

Lo primero es obtener m√°s informaci√≥n para comprender bien el contexto del problema. Preguntar√≠a cosas como:

- ¬øCu√°les son las √°reas espec√≠ficas de la aplicaci√≥n que est√°n lentas (carga inicial, navegaci√≥n, interacciones espec√≠ficas)?
- ¬øEs lento en todas las plataformas (m√≥vil, escritorio) o solo en una?
- ¬øEn qu√© condiciones o momentos de uso notas la lentitud (por ejemplo, al iniciar sesi√≥n, al cargar ciertos datos, en ciertas operaciones)?
- ¬øEst√°s observando una disminuci√≥n del rendimiento con el tiempo, o es algo que ocurre de manera constante?

Con estos detalles, puedo comenzar a identificar patrones y √°reas espec√≠ficas que necesitan ser mejoradas.

**Reproducir el Problema**

Es importante intentar reproducir la lentitud en mi entorno de desarrollo para ver si se puede identificar el origen del problema. Para esto, podr√≠a usar herramientas de monitoreo y registro (logs) en tiempo real para detectar cualquier irregularidad.

**Diagn√≥stico**

Realizar un an√°lisis exhaustivo del rendimiento es clave. Usar√≠a herramientas como:

- Herramientas de desarrollo del navegador (Chrome DevTools, Firefox Developer Tools): Para analizar el tiempo de carga, uso de recursos (CPU, memoria), red (requests/responses), y detectar posibles cuellos de botella.
- Lighthouse: Para realizar auditor√≠as autom√°ticas y obtener una visi√≥n general del rendimiento, accesibilidad, y mejores pr√°cticas.
- Monitoring Tools: Si es una aplicaci√≥n ya en producci√≥n, usar herramientas como New Relic, Datadog, o Sentry puede proporcionar m√©tricas de rendimiento a nivel de servidor, base de datos y frontend.

**Identificar Posibles Causas Comunes**

Algunas √°reas que podr√≠an estar contribuyendo a la lentitud incluyen:

- Tiempo de carga inicial: Si el tiempo de carga es lento, podr√≠a ser por un exceso de archivos JavaScript o CSS pesados, im√°genes no optimizadas, o mala gesti√≥n de cach√©s.
- Problemas con la red o el backend: Consultar con el equipo de backend para verificar la velocidad de las API y la base de datos.
- JavaScript ineficiente: Revisar si hay scripts largos, sincr√≥nicos o mal estructurados que bloqueen el hilo principal.
- Problemas de renderizado en el frontend: Si se trata de una aplicaci√≥n de React, Angular, o similar, revisar la optimizaci√≥n de la renderizaci√≥n, evitar re-renderizados innecesarios, y utilizar t√©cnicas como "memoization", lazy loading y virtualizaci√≥n.

**Optimizaci√≥n**

Una vez identificado el problema, podr√≠a proceder con soluciones como:

- Optimizaci√≥n de im√°genes y recursos est√°ticos: Comprimir im√°genes, usar formatos modernos (como WebP), y asegurarse de que los archivos CSS y JS est√©n minimizados y combinados.
- Lazy loading y code splitting: Cargar solo los m√≥dulos y componentes necesarios en cada p√°gina, para evitar que la aplicaci√≥n cargue m√°s de lo necesario al principio.
- Optimizaci√≥n del backend: Si el problema est√° en la interacci√≥n con el backend, podr√≠a optimizar las consultas a la base de datos o implementar cach√©s.
- Mejorar el rendimiento en la renderizaci√≥n de la UI: En aplicaciones React o Angular, revisar la l√≥gica de renderizado y usar t√©cnicas como memoizaci√≥n, debouncing, o use of virtual DOM optimizations.

**Pruebas de Rendimiento**

Despu√©s de realizar las optimizaciones, es importante medir de nuevo el rendimiento para asegurarse de que el problema haya sido resuelto y si la aplicaci√≥n responde de manera m√°s eficiente.

En resumen, manejar√≠a esta situaci√≥n con un enfoque met√≥dico: primero recolectando informaci√≥n, luego diagnosticando la causa, optimizando el sistema seg√∫n sea necesario, y asegurando que la mejora sea efectiva antes de comunicar los resultados al cliente.

<a id="cic68"></a>

### **¬øCu√°les son los posibles riesgos de adoptar una nueva tecnolog√≠a en el proyecto? ¬øC√≥mo mitigarlos?**

[Volver al indice](#cic-base-2)

En mi experiencia tuve que enfrentar una migracion de una aplicacion muy antigua de AngularJS a Angular. Algunos de los desafios que enfrente fueron los siguientes:

- Hacerle entender al cliente que el cambio era necesario: Se estaban planificando cambios a futuro que incluian el uso de librerias de componentes que no eran compatibles con AngularJS pero si con las nuevas versiones de Angular, por lo que era necesario migrar la aplicacion para no reinventar lo ya hecho.
- Capacitacion del equipo: El equipo no tenia experiencia con Angular, por lo que fue necesario capacitarlos en la nueva tecnologia. Que todo el equipo entendiera la diferencia entre ambos, aunque su mismo nombre (o similar) pueda llevar a confusiones.
- Riesgo de retrasos en el proyecto: La migracion de una aplicacion de AngularJS a Angular no es un proceso sencillo y puede llevar mas tiempo del esperado. Por lo que fue necesario planificar bien los tiempos y recursos necesarios para llevar a cabo la migracion.
- Riesgo de errores y bugs: Al migrar una aplicacion a una nueva tecnologia es probable que aparezcan errores y bugs que no se habian detectado antes. Por lo que fue necesario realizar pruebas exhaustivas para asegurarse de que todo funcionaba correctamente.
- Riesgo de Integraci√≥n con Sistemas Existentes: La aplicacion tenia integraciones con otros sistemas que no habian sido probadas con AngularJS, por lo que fue necesario realizar pruebas de integracion para asegurarse de que todo funcionaba correctamente.

En resumen, los riesgos de adoptar una nueva tecnolog√≠a pueden gestionarse a trav√©s de una planificaci√≥n cuidadosa, pruebas exhaustivas, capacitaci√≥n continua, y una gesti√≥n adecuada de recursos y expectativas. La mitigaci√≥n de estos riesgos no solo depende de un an√°lisis exhaustivo antes de tomar la decisi√≥n, sino tambi√©n de una gesti√≥n activa durante todo el ciclo de vida del proyecto.

<a id="cic69"></a>

### **Algunos miembros de tu equipo no pueden ponerse de acuerdo sobre una soluci√≥n. Discuten y no pueden tomar una decisi√≥n. ¬øC√≥mo resolver√≠as esta situaci√≥n conflictiva?**

[Volver al indice](#cic-base-2)

Cuando los miembros del equipo no pueden ponerse de acuerdo sobre una soluci√≥n y la discusi√≥n se estanca, es importante intervenir de manera constructiva para resolver el conflicto de manera efectiva. Aqu√≠ tienes algunos pasos que seguir√≠a para manejar la situaci√≥n:

### 1. **Escuchar a Todas las Partes:**
   - **Descripci√≥n:** Primero, es esencial dar a cada miembro del equipo la oportunidad de exponer su perspectiva y razones para apoyar su enfoque. Escuchar activamente, sin interrumpir, puede ayudar a comprender mejor las diferentes posiciones y los argumentos detr√°s de cada propuesta.
   - **Acci√≥n:** Organiza una reuni√≥n donde cada miembro pueda explicar su propuesta, sin juicios previos. Esto tambi√©n permite que las emociones y frustraciones se expresen, lo cual es importante para desactivar tensiones.

### 2. **Identificar los Puntos en Com√∫n:**
   - **Descripci√≥n:** Aunque el equipo no est√© de acuerdo en la soluci√≥n, probablemente haya puntos comunes o metas compartidas. Es crucial enfocarse en lo que une al equipo, no en lo que los separa.
   - **Acci√≥n:** Facilita una discusi√≥n en la que se resalten los objetivos comunes del equipo (por ejemplo, la necesidad de una soluci√≥n escalable, f√°cil de mantener o eficiente). Esto ayuda a encaminar el di√°logo hacia un terreno m√°s colaborativo.

### 3. **Fomentar un Debate Constructivo:**
   - **Descripci√≥n:** En lugar de centrarse en que cada miembro ‚Äúgane‚Äù la discusi√≥n, enf√≥cate en fomentar un debate productivo que permita al equipo evaluar las ventajas y desventajas de cada opci√≥n. Es importante que las cr√≠ticas sean constructivas y no personales.
   - **Acci√≥n:** Utiliza preguntas abiertas para guiar el debate: ‚Äú¬øCu√°les son las ventajas de esta propuesta frente a la otra?‚Äù, ‚Äú¬øQu√© riesgos implica esta soluci√≥n?‚Äù, ‚Äú¬øC√≥mo podemos combinar elementos de ambas propuestas para obtener lo mejor de cada una?‚Äù

### 4. **Establecer Criterios Objetivos para la Decisi√≥n:**
   - **Descripci√≥n:** A veces el conflicto surge porque no hay un marco claro para tomar decisiones. Establecer criterios objetivos puede ayudar a enfocar la discusi√≥n hacia una soluci√≥n l√≥gica, en lugar de emocional o subjetiva.
   - **Acci√≥n:** Define criterios claros de evaluaci√≥n para tomar la decisi√≥n, como el costo, el tiempo de implementaci√≥n, la complejidad t√©cnica, la escalabilidad, etc. Esto convierte la decisi√≥n en un an√°lisis objetivo basado en las necesidades del proyecto.

### 5. **Buscar un Compromiso o Soluci√≥n Intermedia:**
   - **Descripci√≥n:** Si las propuestas son mutuamente excluyentes, buscar un compromiso o una soluci√≥n h√≠brida puede ser una forma de resolver el conflicto sin perder el valor de las ideas de cada miembro del equipo.
   - **Acci√≥n:** Prop√≥n integrar los mejores aspectos de ambas soluciones. Por ejemplo, si una propuesta es m√°s simple pero menos escalable, y la otra es m√°s compleja pero m√°s robusta, ¬øpueden fusionarse elementos de ambas para obtener lo mejor de cada una?

### 6. **Tomar una Decisi√≥n de Forma Democr√°tica o por Consenso:**
   - **Descripci√≥n:** Si despu√©s de la discusi√≥n el equipo sigue sin llegar a un acuerdo, una forma de avanzar es tomar una decisi√≥n de forma democr√°tica, donde se vote sobre las opciones disponibles.
   - **Acci√≥n:** Si es apropiado, organiza una votaci√≥n con opciones claras. Si la opci√≥n ganadora no es la preferida por todos, se puede acordar un plan para monitorear su implementaci√≥n y estar dispuestos a realizar ajustes si es necesario.

### 7. **Asignar a un Decisor Final (si es necesario):**
   - **Descripci√≥n:** Si el conflicto persiste y es necesario tomar una decisi√≥n r√°pida para avanzar, puede ser √∫til que un l√≠der o un responsable del proyecto tome la decisi√≥n final. Sin embargo, esto debe hacerse con sensibilidad y considerando que el equipo pueda sentir que su opini√≥n ha sido valorada, incluso si no se les da la √∫ltima palabra.
   - **Acci√≥n:** Como l√≠der o facilitador, podr√≠as tomar la decisi√≥n final despu√©s de haber escuchado a todos los miembros y evaluado los pros y contras. Aseg√∫rate de comunicar de manera clara c√≥mo se lleg√≥ a esa decisi√≥n y c√≥mo se tomaron en cuenta las diferentes perspectivas.

### 8. **Fomentar la Colaboraci√≥n a Largo Plazo:**
   - **Descripci√≥n:** Los conflictos en equipos no solo se resuelven con una sola decisi√≥n, sino con una cultura de trabajo colaborativa y de respeto mutuo. Asegurarte de que el equipo se enfoque en la cooperaci√≥n y el trabajo en equipo evitar√° futuros conflictos.
   - **Acci√≥n:** Despu√©s de resolver la situaci√≥n, es importante reflexionar con el equipo sobre c√≥mo pueden mejorar la comunicaci√≥n y la colaboraci√≥n a futuro. Pueden establecerse normas de trabajo en equipo que fomenten la escucha activa, el respeto y la b√∫squeda de consenso.

### 9. **Revisar el Proceso Despu√©s de la Implementaci√≥n:**
   - **Descripci√≥n:** Despu√©s de tomar una decisi√≥n y ponerla en marcha, realiza un seguimiento para asegurarte de que la soluci√≥n elegida est√° funcionando bien. Si surge alg√∫n problema, es importante estar dispuesto a ajustar el enfoque.
   - **Acci√≥n:** Planifica reuniones peri√≥dicas de retroalimentaci√≥n para evaluar c√≥mo la soluci√≥n est√° funcionando en la pr√°ctica y si se necesitan cambios o mejoras.

---

### Resumen del Enfoque:
1. **Escuchar a todas las partes** para entender sus puntos de vista.
2. **Buscar puntos en com√∫n** y centrar la discusi√≥n en los objetivos del proyecto.
3. Fomentar un **debate constructivo** basado en datos y hechos.
4. Establecer **criterios objetivos** para tomar decisiones.
5. Buscar **compromisos** o soluciones h√≠bridas si es posible.
6. Si es necesario, tomar una decisi√≥n **democr√°tica** o **por consenso**.
7. **Asumir la responsabilidad** de tomar una decisi√≥n final si no hay acuerdo.
8. Fomentar la **colaboraci√≥n y el respeto** en el equipo a largo plazo.
9. **Monitorear la implementaci√≥n** para realizar ajustes si es necesario.

Este enfoque puede ayudar a resolver el conflicto de manera justa y equilibrada, promoviendo la unidad del equipo y asegurando que se tomen decisiones informadas y orientadas al √©xito del proyecto.


<a id="cic70"></a>

### **¬øC√≥mo motivas a tu equipo y qu√© enfoques conoces? ¬øExiste alg√∫n motivador universal para todos?**

[Volver al indice](#cic-base-2)

### 1. **Reconocimiento y Agradecimiento:**
   - Reconocer y agradecer el esfuerzo y los logros del equipo es una forma poderosa de motivaci√≥n. El reconocimiento p√∫blico, premios, o simplemente un agradecimiento sincero pueden tener un impacto positivo en la moral y la motivaci√≥n del equipo.

### 2. **Desarrollo Profesional:**
    - Ofrecer oportunidades de crecimiento y desarrollo profesional es un motivador clave para muchos empleados. Esto puede incluir capacitaci√≥n, mentor√≠a, asignaci√≥n de proyectos desafiantes, y promoci√≥n interna. Aunque esto depende mas de los puestos de management y no tanto de un lider tecnico.

### 3. **Feedback Constructivo:**
    - Proporcionar feedback regular y constructivo es fundamental para la motivaci√≥n. Los empleados valoran la retroalimentaci√≥n honesta y espec√≠fica sobre su desempe√±o, y la oportunidad de aprender y mejorar.

### 4. **Ambiente de Trabajo Positivo:**
    - Crear un ambiente de trabajo positivo y colaborativo es esencial para la motivaci√≥n. Fomentar la comunicaci√≥n abierta, el trabajo en equipo, y la diversi√≥n en el trabajo puede aumentar la satisfacci√≥n y el compromiso de los empleados.

### 5. **Prop√≥sito y Sentido de Contribuci√≥n:**
    - Ayudar a los empleados a comprender c√≥mo su trabajo contribuye al √©xito de la organizaci√≥n y al logro de metas m√°s amplias puede ser un motivador poderoso. Comunicar la visi√≥n y los objetivos de la empresa puede aumentar la motivaci√≥n y el compromiso.

### 6. **Flexibilidad y Equilibrio entre el Trabajo y la Vida Personal:**
    - Ofrecer flexibilidad en los horarios de trabajo, la posibilidad de trabajar desde casa, y apoyar el equilibrio entre el trabajo y la vida personal puede ser un motivador importante para muchos.

### 7. **Participaci√≥n y Empoderamiento:**
    - Involucrar a los empleados en la toma de decisiones, darles autonom√≠a y responsabilidad sobre su trabajo, y permitirles contribuir con ideas y soluciones puede aumentar la motivaci√≥n y el compromiso.


<a id="cic70-1"></a>

### **¬øC√≥mo delegas tareas en tu equipo y c√≥mo var√≠a tu enfoque dependiendo de la antig√ºedad del miembro del equipo?**

[Volver al indice](#cic-base-2)

Delegar tareas de manera efectiva es clave para maximizar la productividad del equipo, fomentar el desarrollo de habilidades y garantizar que los proyectos avancen correctamente. El enfoque para delegar puede variar dependiendo de la experiencia, antig√ºedad y nivel de confianza del miembro del equipo. Aqu√≠ hay una descripci√≥n detallada de c√≥mo podr√≠a manejarlo:

---

### **1. Evaluar la tarea y sus requerimientos**
Antes de delegar, es importante comprender la complejidad, prioridad y dependencia de la tarea. Preguntas clave:
- ¬øRequiere conocimientos t√©cnicos avanzados o espec√≠ficos?
- ¬øTiene una fecha l√≠mite ajustada?
- ¬øImpacta a otras partes del proyecto?
Esto me ayuda a decidir a qui√©n asignar la tarea seg√∫n su nivel de experiencia.

---

### **2. Delegar seg√∫n el nivel de experiencia**
El nivel de experiencia del miembro del equipo influye directamente en la forma en que se delega la tarea y el nivel de supervisi√≥n.

#### **Miembros junior (nivel inicial)**
- **Enfoque**: Darles tareas m√°s claras, delimitadas y con un alcance bien definido. Estas tareas suelen tener menor impacto cr√≠tico y pueden ser oportunidades de aprendizaje.
- **Estrategia**:
  - Proporcionar instrucciones detalladas y un objetivo claro.
  - Asignar tareas donde puedan desarrollar habilidades espec√≠ficas.
  - Supervisar m√°s de cerca y revisar frecuentemente su progreso.
  - Ser accesible para resolver dudas y brindar apoyo.
- **Ejemplo**: "Quiero que implementes este componente siguiendo este dise√±o. Si tienes dudas con la estructura o l√≥gica, revis√©moslas antes de avanzar."

#### **Miembros de nivel medio**
- **Enfoque**: Confiar en su capacidad para completar tareas con menor supervisi√≥n, pero a√∫n dando un poco de orientaci√≥n cuando sea necesario.
- **Estrategia**:
  - Asignar tareas con mayor complejidad, pero que no afecten de manera cr√≠tica al proyecto.
  - Establecer puntos de control para validar el progreso.
  - Fomentar su autonom√≠a y proactividad al resolver problemas.
- **Ejemplo**: "Implementa este m√≥dulo. Aseg√∫rate de integrar correctamente con el backend, y programemos una revisi√≥n despu√©s de que completes el 50%."

#### **Miembros senior (alto nivel de experiencia)**
- **Enfoque**: Darles autonom√≠a total en tareas estrat√©gicas o cr√≠ticas y confiar en su criterio.
- **Estrategia**:
  - Asignar responsabilidades clave, como liderar partes complejas del proyecto.
  - Fomentar que definan su propio enfoque para resolver problemas.
  - Incluirlos en decisiones de alto nivel y en mentor√≠a de otros miembros.
- **Ejemplo**: "Tenemos un problema con la arquitectura actual del proyecto. ¬øPuedes liderar la investigaci√≥n de opciones y proponer una soluci√≥n?"

---

### **3. Supervisi√≥n y seguimiento**
El nivel de supervisi√≥n var√≠a seg√∫n la experiencia del miembro:
- **Junior**: Revisiones m√°s frecuentes (diarias o semanales) para asegurarse de que est√°n en el camino correcto.
- **Nivel medio**: Check-ins ocasionales o revisiones en puntos clave del progreso.
- **Senior**: Supervisi√≥n m√≠nima; confiar en su experiencia y proporcionar feedback al final del ciclo.

---

### **4. Fomentar la comunicaci√≥n abierta**
Independientemente de la antig√ºedad, siempre dejo claro que pueden acercarse si tienen dudas, enfrentan obst√°culos o necesitan ajustar plazos. Esto genera confianza y ayuda a prevenir problemas antes de que se agraven.

---

### **5. Delegar con aprendizaje en mente**
Siempre considero c√≥mo las tareas que asigno pueden contribuir al desarrollo profesional de los miembros del equipo:
- **Junior**: Les doy tareas que ampl√≠en sus conocimientos b√°sicos y habilidades t√©cnicas.
- **Medio**: Les asigno tareas que los expongan a nuevas responsabilidades, como comunicaci√≥n con stakeholders o resolver problemas m√°s abstractos.
- **Senior**: Los desaf√≠o con tareas que requieran innovaci√≥n o pensamiento estrat√©gico.

---

### **6. Retroalimentaci√≥n al finalizar**
Una vez completada la tarea:
- **Para juniors**: Brindar feedback detallado sobre lo que hicieron bien y d√≥nde mejorar.
- **Para niveles medios**: Reconocer su progreso y discutir c√≥mo podr√≠an optimizar su enfoque.
- **Para seniors**: Discutir su trabajo en un nivel m√°s estrat√©gico, como el impacto general en el proyecto.

---

### **Resumen de mi enfoque**
- **Evaluar las habilidades del miembro y las demandas de la tarea.**
- **Asignar tareas de acuerdo con el nivel de experiencia.**
- **Supervisar proporcionalmente seg√∫n la antig√ºedad.**
- **Fomentar la comunicaci√≥n abierta para resolver bloqueos.**
- **Dar retroalimentaci√≥n constructiva despu√©s de completar la tarea.**

Este enfoque ayuda a mantener al equipo alineado, desarrollar sus habilidades y garantizar que las tareas sean manejadas de manera eficiente seg√∫n las capacidades individuales. ¬øQuieres ejemplos espec√≠ficos de tareas t√©cnicas o gesti√≥n para cada nivel?

---

<a id="rea"></a>

# Frontend Frameworks and Libraries

<a id="rea48"></a>

### **¬øDe qu√© hablamos cuando hablamos de una SPA (Single Page App)?**

[Volver al indice](#fe-base)

Una SPA (Single Page Application) son apps web que simulan ser una √∫nica p√°gina con contenido din√°mico. La idea es darle la ‚Äúilusi√≥n‚Äù al usuario de que est√° navegando una aplicaci√≥n de escritorio, que no recarga, no se satura, etc.

Las √∫nicas recargas, o pantallas de carga, son cuando se est√° trayendo informaci√≥n del servidor. No se recarga toda la p√°gina, aun as√≠, solo ciertas partes, dando a una experiencia mucho m√°s fluida.

En resumen:

- Se evita la constante recarga entera de la p√°gina
- La p√°gina no se satura ni realiza peticiones constantes al servidor. √önicamente se pide lo necesario.

<a id="rea50"></a>

### **(Performance) Como evitar mandar muchos eventos inutiles, por ejemplo, ejecutar un search por letra?**

[Volver al indice](#rea-base)

Debounce es un termino de electronica que ayuda a que, por ejemplo, si apretamos varias veces un boton, no se manden muchas veces las instrucciones

```jsx
function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
      const timeoutId = setTimeout(() => {
        setDebouncedValue(value)
    }, delay)

    return () => clearTimeout(timeoutId)
}, [value])

return debouncedValue;
}

// Luego en el component que tiene el search

const queryDebouncedValue = useDebounce(query, 300)

useEffect(() => {
api.search(queryDebouncedValue).then(setProducts);
}, [queryDebouncedValue]);
```

<a id="rea51"></a>

### **Que es async rendering?**

[Volver al indice](#rea-base)

Permite que el renderizado pueda interrumpirse, permitiendo renderizar varios arboles de componentes a la vez sin necesidad de bloquear el hilo principal del navegador.

<a id="rea53"></a>

### **Para que son los eventos sinteticos (SyntheticEvent)?**

[Volver al indice](#rea-base)

Funcionan de la misma forma que los eventos normales de los exploradores. Los eventos sinteticos usan codigo que puede ser aplicado en multiples exploradores web mientras que los eventos normales se enfocan en un solo navegador

Ayuda a que el dev no se preocupe tanto en como manejar un evento segun el navegador para el cual esta desarrollando, ya que estos eventos simulan muchos eventos y garantiza el mismo comportamiento.

<a id="rea54"></a>

### **Que significa prop drilling y como evitarlo?**

[Volver al indice](#rea-base)

Es cuando las props que se comparten acumulan demasiadas dependencias. Da lugar a flujos de datos profundos, dificiles de identificar y refactorizar. Dos formas de resolverlo son:

- Composicion de componentes frente a un mismo juego de datos compartido por varios componentes
- Redux o API Context, aptas para escenarios mas complejos donde conviene manejar un estado global. 


<a id="rea17"></a>

### **Como puedo mejorar la performance de mi Frontend?**

[Volver al indice](#rea-base)

**Paginacion**: No se puede renderizar mucha informacion al mismo tiempo, hace un payload gigante, y satura a la base de datos. Es preferible pedir de a pedazos de data para disminuir el peso en el Backend

**Queries Optimistics**: Mostrar el cambio en la UI independientemente del resultado del servidor, como el like de Instagram, primero se anima, luego se ejecuta la peticion de forma asincrona, y luego se tiene en cuenta el resultado

**Pedir solo lo necesario**: Solo pedir los datos necesarios, no traer cosas de m√°s. Hay muchas aplicaciones hechas front-first, donde el back adapta sus servicios a lo que el front necesita.

**Tener un connection state**: Si no hay internet, no realizar peticiones. Como Youtube, cualquier cosa que quiera hacer el cliente sin internet, no se va a realizar para nada.

**Group Notifications**: Si la aplicacion utiliza notificaciones, hacerlo de a grupos para no hacer jobs grandes

**Evitar queries expensive**: Por ejemplo, Twitter no da la opcion de seguir o dejar de seguir gente de a grupos grandes ya que es innecesariamente caro para el servidor

‚öõÔ∏è¬†**Podemos usar el Profiler que viene con React Dev Tools**
En caso de componentes lentos en React, podemos usar esta herramienta y ver cual fue el componente que causo el problema.

- Flame Chart: Representa el estado de la aplicacion para un commit en particular
- Component chart: Ver cuantas veces se proceso un componente en particular

Para testear el rendimiento de una web se puede utilizar Lighthouse de Google en DevTools

**Lazy Loading**: No cargar todas las imagenes de una, ir cargando a medida que el usuario lo va necesitando.

**Usar Cache**: Si manejamos payloads muy grandes, no conviene cargar todo esto en memoria, se recomienda usar un cache, ir guardando estos payloads y volver a consultarlos a medida que sea necesario

**Usar HTTP 2**: Si necesito hacer demasiados request en paralelo (cosa que no es recomendable), HTTP 2 tiene una coneexion TCP muy buena, para el multiplexing (no siempre es aplicable)

**Hacer UI que llamen lo menos posible al backend**: Que sean UI que dependan de pocos llamados para funcionar (si se puede, ya que hay dependencias entre payloads)

‚öõÔ∏è¬†**No pasar props que no son necesarios**: El propering afecta al rendimiento en React. El estado debe estar tan cerca como pueda de donde se est√© usando. Mientras mas props recibimos, mayor es la dependencia con el componente padre.

‚öõÔ∏è¬†**Evitar renderizados de mas**: Usar useMemo (memorizacion en React) para evitar renderizados o componentes puros

**Tener varias zonas de disponibilidad**: Esto para evitar la latencia en la obtencion de recursos.

<a id="rea26"></a>

### **Que es ECMAScript?**

[Volver al indice](#rea-base)

Es un est√°ndar para JS para escribir funciones complejas, es popular ya que trajo nuevas convenciones y funciones orientadas a objetos a JS.

<a id="rea27"></a>

### **Que es decodeURL y encodeURL?**

[Volver al indice](#rea-base)

- EncodeURL es para convertir una URL a su codificacion hexadecimal

```jsx
encodeURI(uri) // my%20test.asp?name=st%C3%A5le&car=saab
```

- DecodeURL es para convertir la URL codificada a la normal

```jsx
decodeURI(uri) // my test.asp?name=st√•le&car=saab
```

<a id="rea28"></a>

### **Que es escape y unescape?**

[Volver al indice](#rea-base)

- Escape es la responsable de codificar un string para hacer el pase de informacion de un ordenador a otro por una red

```jsx
escape ("Hola? Como estas tu?")); // Hola%3F%20Como%20estas%20tu%21
```

- Unescape la decodifica

```jsx
unescape("Hola%3F%20Como%20estas%20tu%21") // Hola? Como estas tu?
```

<a id="rea29"></a>

### **¬øQue es async, preload y prefetch?**

[Volver al indice](#rea-base)

En JavaScript, `async`, `preload` y `prefetch` son conceptos relacionados pero diferentes:

1. **Async/Await**:
   - `async` y `await` son caracter√≠sticas introducidas en JavaScript para facilitar la escritura y gesti√≥n de c√≥digo as√≠ncrono.
   - `async` se utiliza para declarar que una funci√≥n devuelve una promesa. Esto permite que la funci√≥n se pueda utilizar con `await` para esperar la resoluci√≥n de la promesa dentro de un contexto as√≠ncrono.
   - `await` se utiliza dentro de funciones `async` para esperar la resoluci√≥n de una promesa antes de continuar con la ejecuci√≥n del c√≥digo.
   - Estas caracter√≠sticas son √∫tiles para trabajar con operaciones as√≠ncronas, como solicitudes HTTP, operaciones de lectura/escritura de archivos, y otras operaciones que pueden tomar tiempo y no bloquean la ejecuci√≥n del c√≥digo.

2. **Preload**:
   - `preload` es una directiva HTML que se utiliza para indicar al navegador que cargue un recurso de manera prioritaria.
   - Se puede usar en elementos `<link>` o en elementos `<script>` para pre-cargar recursos como archivos CSS, JavaScript, fuentes web, etc.
   - El navegador descarga estos recursos en segundo plano mientras procesa el resto del contenido de la p√°gina. Esto puede mejorar significativamente los tiempos de carga de la p√°gina al garantizar que los recursos importantes se carguen antes de que sean necesarios.

3. **Prefetch**:
   - `prefetch` es similar a `preload`, pero se utiliza para indicar al navegador que cargue recursos que probablemente se necesitar√°n en el futuro, pero no de manera inmediata.
   - Se utiliza principalmente para cargar recursos relacionados con rutas de navegaci√≥n o acciones del usuario que a√∫n no se han realizado.
   - Al igual que `preload`, se puede usar en elementos `<link>` o en elementos `<script>`, y ayuda a mejorar el rendimiento de la aplicaci√≥n al anticiparse a las necesidades futuras de recursos.

En resumen, `async` y `await` se utilizan en JavaScript para trabajar con c√≥digo as√≠ncrono de manera m√°s legible y manejable, mientras que `preload` y `prefetch` son directivas HTML utilizadas para optimizar la carga de recursos en las p√°ginas web, priorizando recursos importantes o anticip√°ndose a las necesidades futuras de recursos.

<a id="rea30"></a>

### **Cual es la diferencia entre call, bind y apply?**

[Volver al indice](#rea-base)

Por ejemplo tenemos dos objetos y una funcion

```jsx
const user = {
  name: 'Marcos'
};

const business = {
  name: 'Headbook'
}

function showInfo(likes, friends){
  return `${this.name} tiene ${likes} likes y ${friends}`
}
```

En ese caso, el [`this.name`](http://this.name)hace referencia al contexto global. ¬øComo hacer para matchearlo de manera dinamica por objeto?

```jsx
showInfo.call(user, 4, 5); // le pasamos la referencia que deseamos y las props
// Marcos tiene 4 likes y 5 amigos

showInfo.apply(user, [4,5]); // lo mismo pero los params deben ir en un array

const newFunction = showInfo.bind(user);
newFunction(10,15); // hacemos otra funcion que toma otro contexto
```

Basicamente los 3 asocian un objeto a `this`

<a id="rea32"></a>

### **Qu√© es "REPL" y para qu√© sirve?**

[Volver al indice](#rea-base)

REPL, acr√≥nimo en Ingles de "Leer, Evaluar, Imprimir, Bucle". Este shell es utilizado para realizar declaraciones espec√≠ficas en JavaScript.

<a id="rea33"></a>

### **Qu√© es el "demultiplexer"?**

[Volver al indice](#rea-base)

El **demultiplexer,** *es una interfaz encargada de las notificaciones dentro de Node JS.* Es utilizado para recopilar informaci√≥n de eventos espec√≠ficos y formar preguntas, brindando as√≠ lo que se conoce como un **Evento QUE**.

<a id="rea34"></a>

### **Que hace Babel?**

[Volver al indice](#rea-base)

Babel es un compilador para JavaScript. Permite transformar codigo escrito con las ultimas caracteristicas y traducirlo en codigo de JS bien vanilla que pueda ser entendido por navegadores antiguos.

<a id="rea35"></a>

### **Que hace Webpack?**

[Volver al indice](#rea-base)

Es el responsable de producir los bundles a partir del codigo Front. Es un Module Bundler, hay otras opciones como Gulp, Rollup, etc..

Los bundles son paquetes de codigo necesarios para poder llevar a produccion un proyecto, traspilando el codigo y el empaquetado de los modulos en uno o varios archivos compactados, minimizados y optimizados. Es lo que se hace cuando se hace `build`.

<a id="rea36"></a>

### **Que es el server side rendering?**

[Volver al indice](#rea-base)

Es crear paginas HTML renderizadas en servidor para que lleguen listas. Se crean usando NodeJS que generalmente se usa con Express (para utilizar verbos de HTTP).

NextJS es una opcion para usar esto. Favorecen mucho al SEO ya que renderizan la pagina antes de que pueda ser enviada al navegador.

<a id="rea37"></a>

### **Que es Tree Shaking?**

[Volver al indice](#rea-base)

Es remover codigo no usado, como, por ejemplo, imports y exports que no fueron usados. Esto lo hace webpack y Rollup de manera automatica.

<a id="rea38"></a>

### **¬øQue es el SEO?**

[Volver al indice](#rea-base)

Es Search Engine Optimization, es lo que hace que un sitio sea encontrado por Google, y HTML hace un aporte con su metadata para que esto suceda. Por ejemplo, no se recomienda usar muchos <h1> en un HTML para no afectar al SEO.

- Describir la pagina con titulos y fragmentos unicos. Uso de <title> y utilizar terminos claros. Todas las paginas del sitio deben tener una meta descripcion para que aparezca la misma en los resultados del buscador

```html
<head>
  <title>Bienvenidos</title>
  <meta name="description" content="Sitio web">
</head>
```

- Usar codigos de estado HTTP Significativos. Google usa rastreadores sobre los sitios web, o robots, es un programa que descubre y analiza sitios web, en google se llama Google Bot, que usa codigos de estado HTTP. Si uso codigos significativos, le indico al robot si esta pagina debe ser indexada, o no (por ejemplo, si es 404, no es trackeado)
- Solucionar problemas con imagenes y carga diferida. Cargar cuando el usuario este por verlas.

```html
<img src="image.jpg" alt="..." loading="lazy">
```

- Crear dise√±os accesibles, crear paginas para los usuarios, no solo para los motores de busqueda. Un ejemplo para testear la accesibilidad, es cargar la pagina sin JS habilitado.

<a id="rea41"></a>

### **Que es la tipificacion de Variables?**

[Volver al indice](#rea-base)

La tipificaci√≥n de variables, sirve para asignar un n√∫mero a una variable y despu√©s asignar un string a la misma variable.

<a id="rea42"></a>

### **Concepto Truthy and Falsy**

[Volver al indice](#rea-base)

En JavaScript, un valor se considera "falsy" si se convierte en `false` cuando se eval√∫a en un contexto booleano.

```jsx
// Falso
Boolean(0); //false
Boolean(null); //false
Boolean(NaN); //false
Boolean(undefined); //false
Boolean(false); //false
Boolean(""); //false

// Verdadero:
Boolean(1); //true para 1 o cualquier n√∫mero diferente de cero (0)
Boolean("a"); //true para cualquier caracter o espacio en blanco en el string
Boolean([]); //true aunque el array est√© vac√≠o
Boolean({}); //true aunque el objeto est√© vac√≠o
Boolean(function(){}); //Cualquier funci√≥n es verdadera tambi√©n
```

<a id="rea44"></a>

### **Que es la Coercion explicita e Implicita?**

Coercion es la forma en la que podemos cambiar de un tipo de valor a otro

- **Coercion expl√≠cita:** Obligamos que un valor de un tipo cambie a otro valor de otro tipo

```jsx
//Aqu√≠ obligamos a la variable a convertirse en string (coerci√≥n expl√≠cita)
var c = String(a);
console.log(c);

//Aqu√≠ obligamos a la variable a convertirse en n√∫mero (coerci√≥n expl√≠cita)
var d = Number(c);
console.log(d);
```

- **Coercion Implicita:** El lenguaje cambia el tipo de valor por detr√°s

```jsx
//Convierte a 4 en un string y lo concatena con el "7", por esto regresa un string de valor "47"
var a = 4 + "7";

//Convierte al "7" en un n√∫mero y realiza la operaci√≥n, por esto devuelve 28
4 * "7";

var a = 20;
var b = a + ""; //Aqu√≠ concatenamos para convertir la variable a string (coerci√≥n impl√≠cita)
console.log(b);
```

<a id="rea49"></a>

### **Que es la expresion de Funcion Inmediatamente Invocada - Immediately-invoked Function Expression (IIFE)?**

[Volver al indice](#rea-base)

Es una tecnica que se usaba para emular las variables privadas.

```jsx
const modulo = (function(){
  function metodoPrivado () {
  }
  const valorPrivado = "algo"
  return {
    get: valorPrivado,
    set: function(v) { valorPrivador = v }
  }
})()

var x = modulo()
x.get() // "algo"
x.set("Otro valor")
x.get() // "otro valor"
x.valorPrivado //Error
```

<a id="rea50"></a>

### **Qu√© es un Event listener?**

[Volver al indice](#rea-base)

Supongamos que estamos usando una libreria para renderizar items de una coleccion de datos, esta expone un componente llamado RenderItem que tiene una sola prop disponible onClick que no acepta ningun parametro. ¬øY si quiero mandarle un argumento?

```jsx
// Esta es el closure
// en es5
function onItemClick(titulo) {
    return function() {
      alert("Click en " + titulo)
    }
}
// en es6
const onItemClick = titulo => () => alert(`Click en ${titulo}`)

return (
  <Contenedor>
{items.map(item => {
return (
   <RenderItem onClick={onItemClick(item.titulo)}>
    <Titulo>{item.titulo}</Titulo>
  </RenderItem>
)
})}
</Contenedor>
)
```

Creamos una funcion que recibe el titulo que se quiere mostrar y retorna otra funcion que cumple con la definicion de la funcion que RenderItem recibe como prop.

<a id="rea51"></a>

### **isNaN vs Math.isNaN**

[Volver al indice](#rea-base)

NaN son operaciones aritmeticas que no pueden ser representadas correctamente. Ambas funciones tienen como objetivo identificar si un valor es NaN. `isNaN` global aplica una coercion de tipos al argumento que le pasamos, `Math.isNan` no lo hace, lo que hace que sea mas seguro de usar para valores no numericos.

```jsx
isNaN('denu') // devolvera true porque primero intentar√° convertir la cadena a un numero
Number.isNaN('denu') // false porque no convertir√° la cadena a numero
```

### **Metodos String**

```javascript

// .includes() Detecta y devuelve true o false si el String posee un substring en el
const str = 'This is my example string!';
const substr = 'my';

console.log(str.includes(substr)); // true

//.indexOf() es otra forma de saber si un substring se encuentra dentro de un string si el mismo no funciona
stringObj.indexOf("string to check for") // -1 Si no se encuentra

//.replace Reemplaza de un String o un regex un valor por otro, no muta al objeto en si, devuelve lo nuevo
array[0] = array[0].replace("PM", '') // Quita el PM del string dentro de ese array
```

<a id="rea52"></a>

### **Que es Symbol?**

[Volver al indice](#rea-base)

Son valores primitivos de JS (como String, boolean, etc..) agregados al ES6. Son valores unicos en JS, antes si queriamos tener un valor unico debiamos usar objetos (porque solo son iguales a ellos mismos), es util para crear constantes

```jsx
let sym1 = Symbol()
let sym2 = Symbol('denu')
let sym3 = Symbol()

sym1 === sym3 // false
```

Tambien sirve para crear claves unicas en los objetos, donde los autores de librerias, navegadores web o cualquier runtime de ES podra evitar que hubieran colisiones al momento de agregar una prop u objeto global

```jsx
const sym1 = Symbol()
const sym2 = Symbol()

const obj = {}

obj[sym1] = 'a'
obj[sym2] = 'b'
```

<a id="rea53"></a>

### **Cual es la diferencia entre un event loop, microtask y macrotask?**

[Volver al indice](#rea-base)

Javascript ejecuta una linea de codigo por vez. **Event Loop** se encarga de gestionar las funciones asincronas.
Funciona con una Call Stack y una Callback Queue. Cuando hay una linea en ejecucion, se agrega al Call Stack, y cuando finaliza, se elimina. La Queue tiene las funciones callback que deben ejecutarse, no debe haber ninguna funcion ejecutandose en la Call Stack ni debe haber otra funcion adelante suyo en la Queue.
Cuando ejecutamos una funcion con setTimeout, la misma se entrega a Timers API, y aunque setTimeout sea cero, habr√° un retraso en la ejecucion de esta funcion, haciendo que tenga que esperar en la Queue a que termine de ejecutarse el codigo asincrono.

![js](src/js1.png)

* macroTasks: [setTimeout](https://developer.mozilla.org/docs/Web/API/WindowTimers/setTimeout), [setInterval](https://developer.mozilla.org/docs/Web/API/WindowTimers/setInterval), [setImmediate](https://developer.mozilla.org/docs/Web/API/Window/setImmediate), [requestAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame), [I/O](https://developer.mozilla.org/docs/Mozilla/Projects/NSPR/Reference/I_O_Functions), UI rendering
* microTasks: [process.nextTick](https://nodejs.org/uk/docs/guides/event-loop-timers-and-nexttick/), [Promises](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise), [queueMicrotask](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask), [MutationObserver](https://developer.mozilla.org/docs/Web/API/MutationObserver)

Solo despues de que las task en las microTasks estan completas, event loop tomar√° las task de macrotasks. Mientras mas microtasks haya, mas delay habra en los macrotasks. Se recomienda usar microtasks cuando se necesitan hacer cosas de forma asincrona, de otra manera, siempre es recomendado usar macrotasks.

En resumen, su funcionamiento en ingles seria:

- *Tasks* are taken from the *Task (MacroTask) Queue*.
- *Task* from the *Task Queue* is a *Macrotask* != a *Microtask*.
- *Microtasks* are processed when the current task ends and the *microtask* queue is cleared before the next *macrotask* cycle.
- *Microtasks* can enqueue other *microtasks*. All are executed before the next task inline.
- UI rendering is run after all microtasks execution (NA for nodejs).

<a id="rea54"></a>

### **Variable Shadowing - Ocultamiento de Variables**

[Volver al indice](#rea-base)

Se produce cuando una variable que esta en un scope mas reducido tiene el mismo nombre que otra que esta en un scope superior siguiendo la cadena

```javascript
function test() {

var variable = "hola";
console.log(variable);

  function test1() {
    var variable = "denu";
      console.log(variable);
  }

  test1(); // denu
}

test(); // hola
```

---

<a id="cod"></a>

# Conceptos Codigo Limpio, Objetos y Dise√±o

<a id="diag1"></a>

### **Ejemplo de Pseudo-c√≥digo**

[Volver al indice](#cod-base)

```pseudocode
1. pedir el primer numero
2. se guarda el numero en la variable numero
3. se pide el 2do numero
4. se guarda el 2do numero en la variable numero 2
5. preguntarle al usuario que cuenta quiere hacer
6. si el usuario quiere division se chequea que la varieble 2 no sea 0
7. si alguna de las variebles es cero debe aparecer un perro rojo
8. realizar la cuenta
9. guardar resultado en la varieble resultado
10. se muestra el resultado

1. Solicitar el nombre al usuario
2. Guardar nombre en la variable ‚Äúnombre‚Äù
3. Solicitar la cantidad de horas trabajadas
4. Guardar la cantidad en la variable ‚ÄúcantHoras‚Äù
5. calcular el importe a abonar haciendo: importeTotal = cantHoras * VALOR_HORA
6. Mostrar por pantalla: ‚ÄúEl empleado ‚Äù, nombre, ‚Äú debe cobrar: $‚Äù, importeTotal
```

<a id="diag2"></a>

### **Diagramas de Nassi-Schneiderman**

[Volver al indice](#cod-base)

![Diagrama de Nassi-Schneiderman](src/diag1.png)

**Mostrar mensajes por pantalla**

Para representar una salida por pantalla, debe utilizarse un rect√°ngulo, en cuyo √°ngulo superior izquierdo lleve un peque√±o cuadrado marcando una S de Salida.

![Diagrama de Nassi-Schneiderman](src/diag2.png)

**Leer datos desde el teclado**

La E en lugar de la S nos marca una Entrada, es decir, que el programa espera que el usuario ingrese un dato.

En el rect√°ngulo, debe ir el nombre de la variable en d√≥nde se va a almacenar el dato. Asignaci√≥n de valores a variables.

![Diagrama de Nassi-Schneiderman](src/diag3.png)

**Asignar valores a variables**

Para asignarle un dato a una variable, se debe poner a la izquierda de la sentencia el nombre de la variable que va a recibir un valor, el signo ‚Äú=‚Äù y el valor a asignarle. Este valor puede ser:

- Un valor propiamente dicho.
- Una constante (se le asigna el valor de la constante).
- Una variable (se le asigna el valor de la variable).
- El resultado de una operaci√≥n aritm√©tica o l√≥gica.

Por ejemplo:

![Diagrama de Nassi-Schneiderman](src/diag4.png)

Como sucede en este caso, en el que la variable importeTotal recibe el resultado del producto del valor de una constante por una variable, el valor puede darse por alguna operaci√≥n aritm√©tica o l√≥gica.

**Operadores**

Los operadores son la herramienta que tenemos para indicarle al programa que debe realizar cierta operaci√≥n. Existen operadores aritm√©ticos (suma, resta, etc..), de relaci√≥n (Numero mayor a otro numero, etc..) o l√≥gicos (AND, OR, XOR..).

![Diagrama de Nassi-Schneiderman](src/diag5.png)

```jsx
int a = 8;
int b = 3;
System.out.println(‚ÄúLa suma de a + b es ‚Äù + (a + b));
```

**Decisiones simples**

![Diagrama de Nassi-Schneiderman](src/diag6.png)

```jsx
if (a>b) {
  System.out.println(‚Äúel valor de a es mayor que el de b‚Äù);
} else {
  System.out.println(‚Äúel valor de b es mayor o igual que el de a‚Äù);
}
```

En caso de que un empleado trabaje m√°s de 40 horas, el valor hora aumentar√° en un 15%. De esta forma, luego de pedirle al usuario que ingrese la cantidad de horas trabajadas, debemos resolver cu√°nto es el sueldo real, antes de multiplicarlo por esta cantidad

```php
// declaraci√≥n de constantes
const int VALOR_HORA_CAT1 = 20;
const int VALOR_HORA_CAT2 = 30;
const int TOPE_HORAS = 40;

// declaraci√≥n de variables
string nombre;
float cantHoras;
float importeTotal;
```

**Decisiones m√∫ltiples. Sentencia switch**

A diferencia de un si condicional, existen oportunidades en que se debe decidir entre m√°s de dos posibilidades. Las decisiones m√∫ltiples tambi√©n se basan en una comparaci√≥n, pero que puede resolver m√∫ltiples resultados.

Hasta ahora, a los programadores del ejercicio se les pagaba seg√∫n la cantidad de horas trabajadas. Vamos a cambiar esta estrategia de pago y utilizaremos algo m√°s real con el mundo de los sistemas. Dependiendo del Rol que cumpla, podemos decir que un programador Junior est√° en la categor√≠a 1, un semi-senior en la categor√≠a 2 y un senior en la categor√≠a 3.

Vamos a solicitarle entonces, un dato m√°s al usuario. La categor√≠a del programador. De esta forma, las constantes y variables quedar√≠an de este modo:

```php
// Declaraci√≥n de constantes
const int VALOR_HORA_CAT1 = 20;
const int VALOR_HORA_CAT2 = 30;
const int VALOR_HORA_CAT3 = 40;
const int ERROR = -1;

// Declaraci√≥n de variables
string nombre;
float cantHoras;
float importeTotal;
int categoria;
```

![Diagrama de Nassi-Schneiderman](src/diag7.png)

La variable categoria nos indica qu√© es lo que estamos evaluando. Los n√∫meros 1, 2 y 3 indican las opciones posibles. Por √∫ltimo, este diagrama incluye un valor default (por defecto), el cual se ejecuta siempre y cuando la condici√≥n o variable evaluada no corresponda con ninguna opci√≥n.

![Diagrama de Nassi-Schneiderman](src/diag8.png)

**While (ciclo 0-n)**

Se lo llama as√≠ porque puede ser que no haya posibilidad de *entrar* al ciclo (porque ya antes de entrar la condici√≥n del ciclo no se cumple) y porque, una vez que se entr√≥ al ciclo, lo √∫nico que permitir√° que se salga es que la condici√≥n deje de cumplirse. Este ciclo es conocido como *while* y se caracteriza porque la condici√≥n de permanencia antecede al bloque de instrucciones que conforman el ciclo:

![Diagrama de Nassi-Schneiderman](src/diag9.png)

```jsx
while (condicion_de_permanencia) {
  instruccion o bloque de instruccciones;
}
```

Es muy probable que el ciclo est√© controlado por una o m√°s variables que, incluidas dentro de la condici√≥n de permanencia, determinen a partir de su *estado* (si la condici√≥n relacionada con la variable de control se cumple o no) y, por lo tanto, si se permanece dentro del ciclo o si sale y contin√∫a con el resto del programa. Por eso, podemos ver tambi√©n este ciclo de esta manera:

![Diagrama de Nassi-Schneiderman](src/diag10.png)

Uno de los usos habituales de los ciclos es el ingreso validado de valores. Como muchas veces los programas interact√∫an con usuarios y √©stos casi inevitablemente cometer√°n errores, es muy importante que los datos que vamos a usar en nuestros programas est√©n controlados, siendo sus valores acordes a lo que esperamos.

Veamos un ejemplo: queremos que alguien ingrese el n√∫mero de d√≠a de la semana para que nosotros, a partir de eso, hagamos algo (no importa qu√©). Por eso, controlaremos que el n√∫mero est√© dentro del rango esperado (un n√∫mero entre 1 y 7), caso contrario deber√≠amos informar del error y volver a pedir el n√∫mero. El diagrama es el siguiente:

![Diagrama de Nassi-Schneiderman](src/diag11.png)

```java
int numeroDeDia;
System.out.print("Ingresa el numero de dia de la semana (1 a 7)");
numeroDeDia = Integer.parseInt(input.nextLine());
while (numeroDeDia < 1 || numeroDeDia > 7) {
  System.out.print("Me parece que te equivocaste. " +
    "Ingresa el numero de dia de la semana " +
    "asegurandote de que sea un numero " +
    "entre el 1 y el 7 (inclusive):");
  numeroDeDia = Integer.parseInt(input.nextLine());
}
```

**Do-while (ciclo 1-n)**

Se lo llama *ciclo 1-n* porque, a diferencia del *while*, su condici√≥n de permanencia se escribe y chequea luego de ejecutar el bloque de instrucciones que conforman el ciclo. Por lo tanto, siempre se entrar√° al ciclo aunque, al igual que en el caso de *while*, una vez que se entr√≥ al ciclo s√≥lo se permitir√° salir de √©l cuando la condici√≥n deje de cumplirse.

![Diagrama de Nassi-Schneiderman](src/diag12.png)

```java
do {
  instruccion o bloque de instruccciones;
} while (condicion_de_permanencia);
```

Haciendo un paralelo con lo que dijimos anteriormente para el while, podemos ver a este ciclo de esta manera:

![Diagrama de Nassi-Schneiderman](src/diag13.png)

Es importante aqu√≠ resaltar que no hay dos puntos de actualizaci√≥n de la variable de control, y que √©ste es apenas se ingresa al ciclo, ni antes ni despu√©s.

Veamos el ejemplo de la carga del d√≠a de semana tal como se har√≠a con este ciclo. Dado que el dato se carga apenas antes de ser procesado, y dentro del ciclo, en caso de desear un tratamiento especial en caso de error implicar√≠a que usemos un *if* para mostrar el problema. Para hacer eso, aconsejamos usar el ciclo *while*.

<a id="cod1"></a>

### **¬øDe qu√© trata el c√≥digo limpio?**

[Volver al indice](#cod-base)

- Es un codigo facil de leer, entender y modificar
- Se recomienda leer el c√≥digo de otras personas para aprender como son las distintas implementaciones para seguir limpiando nuestro c√≥digo.
- No es posible escribir codigo perfecto a la primera, se consigue mediante un proceso de iteracion continuo que lo va mejorando
- La refactorizacion es segura ya que esta pensada la existencia de los Test Unitarios
- Es recomendable programar en ingles ya que los lenguajes estan en ingles y la mayoria del codigo tambien, las librerias, etc..

<a id="cod2"></a>

### **Nombres Significativos en Codigo Limpio**

[Volver al indice](#cod-base)

En el dia a dia nombramos muchas cosas (clases, paquetes, ficheros, etc..), se deben aclarar nombres claros.

Se deben buscar nombres que revelen intenci√≥n, es decir:

DON¬¥T

```
int d; // Day
int m; // Month
int y; // Year
```

DO

```
int dayOfBirth;
int monthOfBirth;
int yearOfBirth;for (int i = 0; i < numberOfRequests; i++){
    processRequest(requests.get(i));
}
```

- Con el nombre en si mismo ya se debe saber la intencion de la variable y lo que almacena.
- En el caso de los bucles for (como se puede ver en el ejemplo con el int i) se pueden aceptar las declaraciones de variable de una sola letra ya que se realizan solo para hacer iteraciones

Tambien se debe evitar la desinformacion

- Se deben evitar los nombres largos y poco significativos, por ejemplo¬†`ServiceForEfficientUpdateMysqlDatabase`¬†vs¬†`ServiceForEfficientBackupMysqlDatabase`, son largos, podriamos decir que son explicativos, pero a simple vista pueden ser confundidos ya que solo cambia una palabra de ellas entre si.
- Otro ejemplo es¬†`Map<Integer, String> employeeList`, ¬øEs realmente una lista?, no, es un mapa, confunde al programador.
- Otro ejemplo son dos clases, una llamada¬†`ProductData`¬†y otra¬†`ProductInfo`, ¬øCual es la diferencia entre Data e Info? Podrian ser lo mismo

Se deben buscar nombres pronunciables, que sean faciles de buscar. Es mejor elegir un nombre largo a uno corto que no deja claro su significado

DON¬¥T

```
public class InfRcrd {
    private String nm;
    private String snm;
}
```

DO

```
public class Employee {
    private String name;
    private String surname;
}
```

- Se deben evitar las abreviaciones innecesarias
- Los nombres de las clases deben ser nombres, y las funciones deben ser verbos. Es decir, una clase NO debe llamarse¬†`createEmployee`, y un metodo NO deberia llamarse¬†`EmployeeName`¬†ya que no corresponde con su proposito.

<a id="cod3"></a>

### **Dependency Inversion Principle**

[Volver al indice](#cod-base)

Los sistemas mas flexibles son los que dependen de abstracciones y no concreciones. En Java significa que se debe depender de interfaces y clases abstractas, no de implementaciones directas. Hace necesario un mecanismo que nos cree las instancias de las implementaciones que queremos.

La clase `Switch` no depende directamente de la clase `LightBulb`, sino que depende de la abstracci√≥n `SwitchableDevice`. Esto permite que `Switch` sea m√°s flexible y pueda controlar cualquier dispositivo que implemente la interfaz `SwitchableDevice`, no solo la bombilla. Adem√°s, la clase `LightBulb` sigue cumpliendo con el DIP al depender de una abstracci√≥n (`SwitchableDevice`) en lugar de depender directamente de `Switch`. Esto facilita la reutilizaci√≥n y el mantenimiento del c√≥digo, ya que los componentes son m√°s independientes y menos propensos a cambios.

```javascript
// Abstracci√≥n para un dispositivo que se puede encender y apagar
class SwitchableDevice {
    turnOn() {} // M√©todo para encender el dispositivo
    turnOff() {} // M√©todo para apagar el dispositivo
}

// Clase para representar una bombilla
class LightBulb extends SwitchableDevice {
    turnOn() {
        console.log("Light bulb turned on");
    }

    turnOff() {
        console.log("Light bulb turned off");
    }
}

// Clase para representar un interruptor
class Switch {
    constructor(device) {
        this.device = device;
    }

    press() {
        if (this.isOn) {
            this.device.turnOff();
            this.isOn = false;
        } else {
            this.device.turnOn();
            this.isOn = true;
        }
    }
}

// Uso de las clases
const lightBulb = new LightBulb(); // Creamos una bombilla
const switchButton = new Switch(lightBulb); // Creamos un interruptor y lo asociamos con la bombilla

switchButton.press(); // Output: Light bulb turned on
switchButton.press(); // Output: Light bulb turned off

```

<a id="cod4"></a>

### **Concepto SOLID**

[Volver al indice](#cod-base)

Propuesto por Robert C. Martin

S -> Single Responsibility Principle (Principio de responsabilidad unica)

O -> Open-Closed Principle (Principio abierto-cerrado)

L -> Liskov Substitution Principle (Principio de Sustitucion de Liskov)

I -> Interface Segregation Principle (Principio de segregacion de interfaz)

D -> Dependency Inversion Principle (Principio de inversion de dependencia)

Nos ayudaran a

- Crear software escalable con nuevas funcionalidades
- Crear una arquitectura limpia y mantenible
- Escribir C√≥digo mas facil de leer y entender
- M√≥dulos con alta cohesion y bajo acoplamiento

<a id="cod5"></a>

### **Concepto DRY**

[Volver al indice](#cod-base)

Don‚Äôt Repeat Yourself, si hay una pieza de programaci√≥n que se repite en mas de un lugar, se debe crear una funci√≥n de la misma

<a id="cod6"></a>

### **Concepto KISS**

[Volver al indice](#cod-base)

Keep it Simple Stupid, no escribir codigo que nadie pueda entender o leer, mantener todo simple

<a id="cod7"></a>

### **Concepto YAGNI**

[Volver al indice](#cod-base)

You Aren‚Äôt Gonna Need it! No escribir codigo de mas solo porque puede que lo necesites mas adelante. Implementar algo solo si es necesario en el momento

<a id="cod8"></a>

### **Concepto LOD**

[Volver al indice](#cod-base)

Law Of Demeter, quien puede hablar con quien, una unidad puede comunicarse solo con sus unidades cercanas

<a id="cod9"></a>

### **Funciones Limpias**

[Volver al indice](#cod-base)

- Las funciones deben ser claras, concisas, faciles de leer y modificar
- Deben ser peque√±as, deben hacer una unica cosa, un unico nivel de abstraccion. Debemos separar lo mas posible todas las funciones, haciendo que sean reutilizables.
- No deben recibir muchos parametros
- No tienen efectos secundarios por fuera de su proposito principal
- Devuelven excepciones en lugar de codigos de error

<a id="cod10"></a>

### **Unico Nivel de abstraccion**

[Volver al indice](#cod-base)

Separar las responsabilidades en las entidades correspondientes.

DON¬¥T

```java
public class Person {
    public void drive (Car car) {
        car.openDoor();
        car.setDriver(this);
        // Esto no es responsabilidad de la Persona, es responsabilidad del Vehiculo
        car.getBattery().connect();
        car.setEngine().start();
    }
}
```

DO

```java
public class Car {
    Battery battery;
    Engine engine;    public void start(){
        battery.connect();
        engine.start();
    }
}public class Person {
    public void drive (Car car){
        car.openDoor();
        car.setDriver(this);
        car.start();
    }
}
```

<a id="cod11"></a>

### **Manejo limpio de Parametros**

[Volver al indice](#cod-base)

Se deben evitar las funciones que reciben mas de 3 argumentos, muchos argumentos es una mala encapsulaci√≥n. La mejor funcion es la que menos argumentos recibe.

DON¬¥T

```java
public User createUser(String username, String password, String name, String lastname, String address);public Circle createCircle(double x, double y, double radius)
```

DO

```java
public User createUser(UserFormData userFormData)// Pasamos x e y a un objeto "Point" (centro del circulo) que es mucho mas explicativo
public Circle createCircle(Point center, double radius)
```

<a id="cod12"></a>

### **Cuales son los beneficios de una Code Review?**

[Volver al indice](#cod-base)

Los objetivos clave de la revisi√≥n de c√≥digo son identificar errores de desarrollo iniciales y facilitar una base de c√≥digo mantenible. El proceso de revisi√≥n de c√≥digo puede ayudar a su equipo a prever posibles problemas t√©cnicos que son mucho m√°s f√°ciles de abordar en una etapa temprana.

La revisi√≥n de c√≥digo resulta en varios otros beneficios para sus proyectos y equipo; lo m√°s significativo: menos defectos, mejor intercambio de conocimientos, est√°ndares m√°s consistentes y mejor cumplimiento.

**Menos defectos**

A menudo es m√°s f√°cil para un revisor con una perspectiva externa identificar errores estructurales (por ejemplo, c√≥digo muerto, errores de l√≥gica o algoritmos, preocupaciones de rendimiento o arquitectura, etc.) y errores funcionales (cuando el c√≥digo no funciona como se esperaba).

Incluso las revisiones de c√≥digo cortas e informales pueden tener un impacto significativo en la calidad del c√≥digo y la frecuencia de errores.

**Compartir conocimiento**

El valioso conocimiento que su equipo comparte durante el proceso de revisi√≥n de c√≥digo se relaciona principalmente con la funcionalidad de una aplicaci√≥n espec√≠fica, su dominio y su l√≥gica empresarial. Tambi√©n cubre las mejores pr√°cticas de codificaci√≥n, incluyendo t√©cnicas de optimizaci√≥n y refactorizaci√≥n.

El intercambio de conocimientos garantiza que todos los miembros del equipo est√©n en la misma p√°gina y fortalece la comunicaci√≥n y cooperaci√≥n positivas.

**Standards Consistentes**

La revisi√≥n de c√≥digo garantiza que los miembros de su equipo sigan la gu√≠a de estilo acordada. La consistencia en una base de c√≥digo hace que sea m√°s f√°cil de leer y comprender, previene errores y facilita la colaboraci√≥n entre desarrolladores regulares y migratorios. El c√≥digo legible es m√°s reutilizable, sin errores y a prueba de futuros cambios.

El autor del c√≥digo puede no ser capaz de juzgar la legibilidad de su fragmento de c√≥digo tan f√°cilmente como lo puede hacer un revisor. Seguir est√°ndares consistentes hace que la cooperaci√≥n entre autores y revisores de c√≥digo sea m√°s f√°cil.

**Compliance**

La revisi√≥n de c√≥digo es una excelente manera de evitar trampas t√©cnicas comunes. Por ejemplo, si su aplicaci√≥n tiene requisitos estrictos de seguridad, su especialista en seguridad local deber√≠a revisarla para asegurarse de que cumpla con los requisitos de cumplimiento.

Un revisor tambi√©n puede detectar y reemplazar dependencias externas reci√©n introducidas con licencias inapropiadas o vulnerabilidades conocidas antes de que aparezcan en producci√≥n.

Que puede suceder si evito una Code Review?

**Menos Calidad de C√≥digo estructural**

La falta de revisi√≥n de c√≥digo puede afectar la calidad estructural del c√≥digo, haci√©ndolo ilegible y dif√≠cil de mantener.

**Menos Calidad de c√≥digo Funcional**

Eludir la revisi√≥n de c√≥digo puede afectar negativamente la calidad funcional del c√≥digo. El c√≥digo de baja calidad, a su vez, disminuye la calidad del producto.

**Se comparte poco conocimiento**

La falta de revisi√≥n de c√≥digo puede hacer que algunos miembros de tu equipo pierdan informaci√≥n importante. Esto puede llevar a una situaci√≥n en la que varios miembros del equipo est√©n implementando funcionalidades similares en lugar de reutilizar la soluci√≥n existente.

Adem√°s, la falta de compartir conocimientos adecuadamente puede resultar en la p√©rdida de algunas funcionalidades empresariales reutilizables.

**Re-trabajo**

La falta de transparencia y retroalimentaci√≥n temprana en tu equipo puede requerir retrabajo en una etapa posterior. Por ejemplo, mientras trabajan en dos m√≥dulos diferentes, varios miembros del equipo pueden incorporar diferentes enfoques t√©cnicos. Para hacer que la base de c√≥digo sea consistente, uno de los enfoques tendr√° que ser refactorizado.

Este tipo de situaci√≥n puede llevar a conflictos interpersonales entre los miembros del equipo, as√≠ como trabajo adicional.

**Posibles problemas t√©cnicos**

Sin revisi√≥n de c√≥digo, tu equipo tiene una mayor probabilidad de introducir problemas de seguridad que afecten a los usuarios finales. Estos problemas podr√≠an llevar a brechas de datos sensibles, vulnerabilidad a ataques de ransomware y otras consecuencias negativas para tus clientes y la reputaci√≥n de tu empresa...

<a id="cod13"></a>

### **Que tipos de Code review existen?**

[Volver al indice](#cod-base)

**Peer Review**

La revisi√≥n por pares permite que varios miembros del equipo revisen el c√≥digo en diferentes momentos. Su conveniencia lo convierte en un tipo de revisi√≥n popular.

Con la ayuda del sistema de control de versiones, el autor pone el c√≥digo a disposici√≥n de otros miembros del equipo para su revisi√≥n. Despu√©s, el autor comienza a trabajar en otra tarea mientras sus compa√±eros realizan la revisi√≥n. Diversas herramientas y estrategias de ramificaci√≥n facilitan el proceso.

La revisi√≥n por pares puede ser interna o externa. Cuando su equipo realiza una revisi√≥n interna por pares, es una excelente manera de mejorar el intercambio de conocimientos. Su equipo tambi√©n puede optar por la ayuda de un especialista externo con experiencia espec√≠fica que no forma parte del equipo.

**Specialist Review**

La revisi√≥n de un especialista es un ejemplo de pr√°ctica de revisi√≥n de c√≥digo entre equipos.

A veces, un fragmento de c√≥digo puede requerir la revisi√≥n de un especialista que tiene habilidades espec√≠ficas y conocimientos profundos en un √°rea particular. Muy a menudo, este tipo de especialista no forma parte del equipo de desarrollo.

La revisi√≥n de un especialista podr√≠a ser una revisi√≥n arquitect√≥nica, de seguridad o de rendimiento. Este tipo de revisi√≥n puede ser requerida peri√≥dicamente o a pedido.

**Instant Code Review**

La revisi√≥n instant√°nea de c√≥digo permite que varios miembros del equipo revisen el c√≥digo simult√°neamente. Por lo general, se lleva a cabo como programaci√≥n en pareja: cuando dos miembros del equipo escriben c√≥digo y lo revisan l√≠nea por l√≠nea.

Este enfoque puede ser apropiado para dos desarrolladores de aproximadamente el mismo nivel de madurez que trabajan juntos en un problema empresarial complejo. Tambi√©n es √∫til si los desarrolladores m√°s senior quieren ayudar a los desarrolladores junior a mejorar sus habilidades t√©cnicas: un desarrollador senior codifica y explica lo que est√° haciendo l√≠nea por l√≠nea, mientras que un desarrollador junior observa y aprende. El mismo principio se aplica a la integraci√≥n, cuando un reci√©n llegado observa y escucha a otro miembro del equipo codificando y explicando las ideas esenciales l√≠nea por l√≠nea.

<a id="cod14"></a>

### **Domain Driven Design**

[Volver al indice](#cod-base)

Este dise√±o se enfoca en el dominio del problema, es decir, en el problema que se est√° tratando de resolver. Se enfoca en el lenguaje que se usa para describir el problema y en c√≥mo se resuelve. Se basa en la idea de que el dise√±o de software debe reflejar el dominio del problema, y no al rev√©s.

Por ejemplo, para desarrollar el software de un hospital, debo tener en cuenta las necesidades del usuario y sobre todo, si es necesario, un marco juridico, mas si se trata de informacion sensible sobre pacientes.

**Software del modelo del dominio anemico**: No tiene un conocimiento sobre el dominio donde el software se desempe√±a.

**Software del modelo del dominio rico**: Tiene un conocimiento profundo sobre el dominio donde el software se desempe√±a.

Se deben conocer las reglas, casos de uso, y las necesidades del usuario para poder desarrollar un software que se adapte a las necesidades del usuario. Se deben conocer los datos que necesitan recopilar los medicos, las enfermeras, y los pacientes, y c√≥mo se deben almacenar y procesar esos datos.

<a id="cod15"></a>

### **¬øQu√© es un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

Un patr√≥n de dise√±o es una soluci√≥n descubierta para un problema inform√°tico que se presenta recurrentemente y de una forma especifica, para que sea reutilizada en otros desarrollos en cualquier otro lenguaje.

<a id="cod16"></a>

### **En qu√© se inspiran los patrones de dise√±o?**

[Volver al indice](#cod-base)

Se inspiran en los patrones de construcci√≥n en la arquitectura, en esa disciplina se usa el mismo concepto para la comunicaci√≥n entre colegas y en otros procesos de la disciplina.

<a id="cod17"></a>

### **¬øQu√© se obtiene con la implementaci√≥n de patrones de dise√±o?**

[Volver al indice](#cod-base)

- **Reutilizaci√≥n de c√≥digo**: Se puede reutilizar el c√≥digo que ya ha sido probado y que se sabe que funciona.
- **Facilita la comunicaci√≥n**: Los patrones de dise√±o permiten que los desarrolladores se comuniquen de una manera m√°s efectiva.
- **Facilita el mantenimiento del c√≥digo**: Los patrones de dise√±o permiten que el c√≥digo sea m√°s f√°cil de mantener.
- **Facilita la escalabilidad del c√≥digo**: Los patrones de dise√±o permiten que el c√≥digo sea m√°s f√°cil de escalar.

<a id="cod18"></a>

### **¬øPara qu√© sirven los patrones de dise√±o?**

[Volver al indice](#cod-base)

Son soluciones bas√°ndonos en la experimentaci√≥n de problemas comunes y recurrentes en varios proyectos de programaci√≥n. Algunos pueden parecer abstractos en su explicaci√≥n, le delegan al dise√±ador el esfuerzo de reconocer el problema y adaptar la soluci√≥n. Son utilizados tambi√©n como un facilitador de la comunicaci√≥n, es decir, si todos los especialistas de IT conocen estos patrones de dise√±o, pueden ver cualquier proyecto y ya intuir como funciona, y cu√°l es la idea detr√°s de su tipo de organizaci√≥n. Son dise√±os orientados al cambio.

<a id="cod19"></a>

### **¬øCu√°les son los elementos de un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

Los elementos de un patr√≥n de dise√±o incluyen el nombre del patr√≥n, que es el nombre por el cual el patr√≥n es reconocido o conocido. Puede haber m√°s de un nombre para un mismo patr√≥n.

<a id="cod20"></a>

### **¬øCu√°les son los tipos de patrones de dise√±o?**

[Volver al indice](#cod-base)

- **Creacionales**: Se encargan de la creaci√≥n de objetos, tratan de abstraer el proceso de creaci√≥n de objetos. Resuelven problemas relacionados con la creaci√≥n o instanciacion de objetos
- **Estructurales**: Se encargan de la composici√≥n de clases o de objetos. Resuelven problemas relacionados a la estructura y composici√≥n interna de los objetos, como problemas de asociaci√≥n y agregaci√≥n. No son f√°ciles de entender a la primera, y la mayor√≠a son muy abstractos.
- **Comportamiento**: Se encargan de la comunicaci√≥n entre objetos. ¬†Estudian el comportamiento orientado a la comunicaci√≥n entre objetos y conjuntos de objetos
- **De arquitectura**: Son patrones a nivel componente, normalmente operan en alg√∫n tipo de capa l√≥gica. Expresan un esquema organizativo fundamental. El primer patr√≥n postulado que define a este en GoF es el MVC
- **De interacci√≥n**: La primera aplicaci√≥n de este se dio en el dise√±o de interfaces de usuarios. Son 5 patrones de interfaz,¬†Windows per task, Few Panes, Standard Panes, Nouns and Verbs y Short Men√∫.
- **Del GRASP**: Son patrones generales de software relacionados con la asignaci√≥n de responsabilidades. Son una serie de buenas pr√°cticas de aplicaci√≥n recomendable en el dise√±o de software que provienen de autores anteriores y paradigmas previos.
- **De negocio**: Obedecen a situaciones de negocio espec√≠fico
- **Dial√©cticos**: Son patrones de bajo nivel espec√≠ficos para un lenguaje de programaci√≥n o entorno concreto

<a id="cod21"></a>

### **¬øQu√© es la intenci√≥n y motivaci√≥n de un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

La intenci√≥n y motivaci√≥n de un patr√≥n de dise√±o se refiere a un resumen del problema que resuelve este patr√≥n. Es un p√°rrafo breve que explica su necesidad.

<a id="cod22"></a>

### **¬øQu√© es la aplicabilidad de un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

La aplicabilidad de un patr√≥n de dise√±o menciona los usos m√°s comunes y los criterios para aplicar cierto patr√≥n. Suelen cambiar mucho con el tiempo dependiendo de la evoluci√≥n de algunos frameworks o lenguajes.

<a id="cod23"></a>

### **¬øQu√© es la estructura de un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

La estructura de un patr√≥n de dise√±o es una enumeraci√≥n y descripci√≥n de las entidades o clases concretas y abstractas, que explican los roles dentro del patr√≥n. Pueden ser peque√±os diagramas de clases que describan las clases e interfaces participantes o componentes del patr√≥n.

<a id="cod24"></a>

### **¬øQui√©nes son los participantes de un patr√≥n de dise√±o?**

[Volver al indice](#cod-base)

Los participantes de un patr√≥n de dise√±o son tanto las clases abstractas como concretas que participan en el patr√≥n en las documentaciones.

<a id="cod25"></a>

### **Patrones Estructurales**

[Volver al indice](#cod-base)

- **Adapter**: Se adapta a un determinado objeto para que pueda ser usado por otro, dado que de otro modo no se podr√≠a. Su nivel de uso es muy alto
- **Bridge**: Nos permite separar a una abstracci√≥n de su implementaci√≥n. Su uso es nivel medio a bajo
- **Composite**: Permite, ayuda y simplifica la forma de tratar a objetos simples y compuestos de un mismo modo. Su uso es medio
- **Decorador**: Suma o a√±ade funcionalidad a un objeto de manera din√°mica. Su empleo es medio, se emplea usualmente con Composite.
- **Facade**: Provee de una interfaz o punto de entrada para acceder a la funcionalidad de un grupo de objetos de un sub sistema. Su utilizaci√≥n es alto.
- **Flyweight**: El patr√≥n busca reducir la redundancia de objetos que viven en memoria cuando se trata de objetos peque√±os con la misma informaci√≥n. Su empleo es medio, alto.

<a id="cod26"></a>

### **Patrones Creacionales**

[Volver al indice](#cod-base)

- **Singleton**: Se ocupa de que exista una unica instancia de un determinado objeto. Es muy usado
- **Factory Method y/o Factory Simple**: Busca simplificar la creacion de objetos de una determinada familia definiendo una interfaz en comun. Su nivel de uso es alto.
- **Abstract Factory:** Busca centralizar la fabricaci√≥n de objetos de distintas familias en √∫nicamente un lugar. Su empleo es bajo.
- **Builder**: Se ocupa de construir objetos complejos. Su empleo es bajo.
- **Prototype**: Nos permite crear una copia exacta (o casi) de un objeto en memoria directamente sin necesidad de interactuar con su caso. Su utilizaci√≥n es bajo.
- **Object Pool**: No es un patr√≥n GoF. Permite generar, tener, mantener y reutilizar una serie de objetos en memoria para reducir el trabajo de los Garbage Collector. Su uso es medio a alto.

<a id="cod27"></a>

### **Patrones Comportamiento**

[Volver al indice](#cod-base)

Como los objetos se van a comportar y a cambiar su comportamiento.

- **State**: Suele presentarse cuando es necesario que un objeto modifique su comportamiento cuando cambia su estado interno (Muy usado en React). Empleo alto.
- **Strategy**: Permite disponer de varios m√©todos para resolver un problema y permitir elegir cual de ellos se usara en tiempo de ejecuci√≥n. Uso alto.
- **Observer**: Define una dependencia entre un objeto determinado a muchos otros (llamados observadores) de manera que cuando se produce un cambio de estado en el sujeto observado, los observadores dependen de el para que el resto se actualice solo. Uso alto.
- **Mediator**: Es cuando se define que un objeto coordine la comunicaci√≥n entre objetos de distintas clases y que no fueron dise√±ados para comunicarse entre si. Empleo medio a bajo.
- **Command**: Encapsula una operaci√≥n en un objeto, permitiendo ejecutar esa operacion sin conocer el contenido de la misma. Empleo medio.
- **Template method**: Define en una operaci√≥n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Esto permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura. Uso medio a bajo
- **Memento**: Permite volver a estados anteriores de un objeto y/o sistema. Uso medio bajo
- **Iterator**: Permite recorrer sobre objetos compuestos independientemente de la implementaci√≥n de los mismos
- **Interpreter**: Dado un lenguaje, define una gram√°tica para dicho lenguaje, asi como las herramientas para interpretarlo. Uso bajo.
- **Chain of Responsability**: Permite establecer la linea que deben llevar los mensajes para que los objetos hagan la tarea indicada
- **Visitor**: Permite definir nuevas operaciones sobre una jerarqu√≠a de clases sin cambiar las clases sobre las que opera. Uso bajo

<a id="cod28"></a>

### **Excepciones en lugar de codigos de error**

[Volver al indice](#cod-base)

Conviene encerrar todo nuestro codigo que puede fallar dentro de un try/catch y manejarlo mediante el mismo que logear los errores al momento en que suceden, el flujo normal queda mucho mas claro.

DON¬¥T

```java
public void restoreDatabase(){
    if (state() == 'OK'){
        realizoUnaAccion();
        if (state() == 'OK'){
            Logger.log("Todo salio bien");
        }
        else {
            Logger.log("Error");
        }
    }
    else {
        Logger.log("Error");
    }
}
```

DO

```java
public void restoreDatabase(){
    try {
        realizoUnaAccion(); // Throws excepcionUna
        realizoOtraAccion(); // Throws excepcionDos
        Logger.log('Todo Salio Bien')
    }
    catch (excepcionUna e){
        Logger.log("Ocurrio un error");
    }
    catch (excepcionDos e){
        Logger.log("Ocurrio un error");
    }
}
```

Tambien seria ideal separar las funciones try/catch en una sola funcion, asi tenemos los caminos por separado. Cada funcion puede tratar con un solo nivel de abstraccion.

```java
public void restoreDatabase(){
    try {
        realizoTodasLasAcciones(); // Throws excepcionUna y excepcionDos
    }
    catch (excepcionUna e){
        Logger.log("Ocurrio un error");
    }
    catch (excepcionDos e){
        Logger.log("Ocurrio un error");
    }
}
```

<a id="cod29"></a>

### **Manejo de Comentarios en el codigo**

[Volver al indice](#cod-base)

Se nos ense√±a mucho que debemos comentar mucho nuestro codigo. El buen codigo deberia poder leerse con casi ningun comentario.

- Solo agregar comentarios cuando es estrictamente necesario
- Los comentarios se desactualizan muy rapidamente ya que el codigo cambia mucho, son muy complicados de mantener, por eso no son aconsejables
- Si el codigo tiene demasiados comentarios es porque no se entiende (Refactorizacion necesaria) o porque los comentarios son demasiado obvios (eliminarlos en ese caso)
- Los comentarios de Javadocs en una API publica si son comentarios utiles.

DON¬¥T

```java
// --- En este caso el comentario esta ya que la condicion del if no es lo suficientemente explicativa por si misma ---

// Check if password is secure
if (password != null && password.length > 9 && !password.contains(username)){}
// --- Comentario generado automaticamente por javadoc, no nos suma nada, es innecesario ---

/*
* @param title The title of the book
* @param descripcion The description of the book
*
*/
public void addBook(String title, String description){}

// --- NUNCA dejar codigo comentado pensando que lo vamos a usar en un futuro, para eso usamos control de versiones ---

//public void oldWayOfAddingBook(Request request){}
```

DO

```java
// --- Reemplazamos la condicion confusa por una funcion que resume lo que hace ---

if(isSecure(password))
// --- Se explican cosas que suman al codigo, por ejemplo, que busca matchear un regex que no se puede ver a simple vista ---
// Matches Date in format 17-09-2022 18:05:15
Pattern.matches(regexDate, date);

// --- Se dejan cosas en TODO para un futuro ---
// TODO expect this method to change when..
public void login (User user) {}
```

<a id="cod30"></a>

### **Acomplamiento artificial**

[Volver al indice](#cod-base)

Los elementos que no dependan entre si no deben estar acoplados. Por ejemplo, en el caso de PI dentro del ejemplo, nos conviene hacer una variable global del mismo, ya que es un valor que puede ser usado por cualquier otro elemento del codigo y no es algo exclusivo del Circulo.

```java
public class Circle {
    private static final Double PI = 3.14159265359;
    private Double radius;
    public Circle(Double radius) {
        this.radius = radius;
    }
    public Double calculateArea() {
        return PI * radius * radius;
    }
}
```

<a id="cod31"></a>

### **Unchecked Exceptions**

[Volver al indice](#cod-base)

- Son excepciones que heredan de¬†`RuntimeException`, como¬†`NullPointerException`, muy com√∫n en Java, y en lenguajes compilados
- Se pueden tratar con try-catch pero no es necesario al 100%
- Las excepciones checked son las excepciones normales que heredan de¬†`Exception`, si no son tratadas, el programa directamente no compila, ensucia mucho el codigo.
- Se recomienda usar checked Excepcions si se trata de una libreria critica donde se quiera obligar a quien usa la liberia a manejar estas excepciones.

```jsx
public class Driver {
    public void startDriving() {
        try {
            startCar();
        }
        catch (CarCrashException e) {
            logger.log(e);
        }
    }
}

public class Car {
    public void start() throws BatteryDeadException, EngineStartException {
        // ...
    }
}

public class Battery {
    public void start() throws BatteryDeadException {
        // ...
    }
}

public class Engine {
    public void start() throws EngineStartException {
        // ...
    }
}
```

<a id="cod32"></a>

### **Excepciones en lugar de c√≥digos de error**

[Volver al indice](#cod-base)

Usando excepciones no hay porque tratar el error en el momento. Nos conviene separar la gestion de errores del codigo con el flujo correcto.

```jsx
public void sendShutDown() {
    try {
        tryToShutDown();
    }
    catch (DeviceShutDownError e) {
        logger.log(e);
    }
}

private void tryToShutDown() throws DeviceShutDownError {
    DeviceHandle handle = getHandle(DEV1); // Throws DeviceShutDownError
    // ...
    sendShutDown(handle);
}
```

<a id="cod33"></a>

### **Gesti√≥n de errores**

[Volver al indice](#cod-base)

- Se debe buscar un codigo limpio pero tambien robusto en si mismo
- La gestion de errores puede ensuciar el codigo, hay que prestarle especial atenci√≥n
- Se deben devolver excepciones en lugar de c√≥digos de error
- Se deben usar excepciones unchecked
- No devolver ni pasar¬†`null`

<a id="cod34"></a>

### **Indentaci√≥n**

[Volver al indice](#cod-base)

- Se recomiendan dos o cuatro espacios de indentacion
- El maximo recomendado de caracteres por linea es de 100 caracteres, si no, se tendr√° que partir la linea
- Se deben seguir siempre las mismas reglas

DON¬¥T

```java
public Integer tripleSum(Integer a, Integer b, Integer c){
if (a==null||b==null||c==null){
return null;
}
return a+b+c;
}
```

<a id="cod35"></a>

### **C√≥digo en el nivel de abstracci√≥n incorrecto**

[Volver al indice](#cod-base)

El m√©todo¬†`changeRadioChannel`¬†esta mal, ya que no todos los veh√≠culos tienen radio. El m√©todo no deber√≠a estar en esa clase tan general como lo es¬†`Vehicle`

```java
public class Vehicle() {
  public void turnOn();
  public void turnOff();
  public Integer getLeftAutonomyInKm();
  public void changeRadioChannel(RadioCHannel selectedChannel);
}
```

<a id="cod36"></a>

### **Acoplamiento (Evitar)**

[Volver al indice](#cod-base)

Grado en que dos modulo software estan relacionados entre si. Con un buen dise√±o, se crean modulos poco acoplados, haciendo que si se modifica un modulo, afecte lo menos posible al resto (Misma logica con las arquitecturas de microservicios o microfrontends)

```javascript
// -----------M√≥dulo con acoplamiento alto-----------
const HighCouplingModule = (function() {
    // Funci√≥n para calcular el √°rea de un c√≠rculo
    function calculateCircleArea(radius) {
        return Math.PI * radius ** 2;
    }

    // Funci√≥n para calcular el √°rea de un rect√°ngulo
    function calculateRectangleArea(length, width) {
        return length * width;
    }

    // Funci√≥n para imprimir el √°rea de una forma geom√©trica
    function printArea(shape, ...args) {
        let area;
        if (shape === 'circle') {
            area = calculateCircleArea(...args);
        } else if (shape === 'rectangle') {
            area = calculateRectangleArea(...args);
        } else {
            throw new Error("Shape not supported");
        }
        console.log(`The area of the ${shape} is: ${area}`);
    }

    // Exponer las funciones p√∫blicas del m√≥dulo
    return {
        printArea
    };
})();

// Uso del m√≥dulo con acoplamiento alto
HighCouplingModule.printArea('circle', 5); // Output: The area of the circle is: 78.53981633974483
HighCouplingModule.printArea('rectangle', 4, 6); // Output: The area of the rectangle is: 24

// -----------M√≥dulo con acoplamiento bajo-----------

const LowCouplingModule = (function() {
    // Funci√≥n para calcular el √°rea de un c√≠rculo
    function calculateCircleArea(radius) {
        return Math.PI * radius ** 2;
    }

    // Funci√≥n para calcular el √°rea de un rect√°ngulo
    function calculateRectangleArea(length, width) {
        return length * width;
    }

    // Exponer las funciones p√∫blicas del m√≥dulo
    return {
        calculateCircleArea,
        calculateRectangleArea
    };
})();

// M√≥dulo independiente
const IndependentModule = (function() {
    // Funci√≥n para imprimir el √°rea de una forma geom√©trica
    function printArea(shape, ...args) {
        let area;
        if (shape === 'circle') {
            area = LowCouplingModule.calculateCircleArea(...args);
        } else if (shape === 'rectangle') {
            area = LowCouplingModule.calculateRectangleArea(...args);
        } else {
            throw new Error("Shape not supported");
        }
        console.log(`The area of the ${shape} is: ${area}`);
    }

    // Exponer las funciones p√∫blicas del m√≥dulo
    return {
        printArea
    };
})();

// Uso del m√≥dulo con acoplamiento bajo
IndependentModule.printArea('circle', 5); // Output: The area of the circle is: 78.53981633974483
IndependentModule.printArea('rectangle', 4, 6); // Output: The area of the rectangle is: 24
```

<a id="cod37"></a>

### **Cohesion (Fomentar)**

[Volver al indice](#cod-base)

Es el grado en que los elementos de un modulo estan relacionados entre si. Mientas mas alta la cohesion en el codigo, mejor

En el ejemplo la cohesion es baja, las funciones se relacionan con distintas variables. Se podria separar en 2 clases, una que sea para el manejo de niveles y otra para el manejo del jugador.

Ejemplo de alta cohesion:

```javascript
// M√≥dulo para manejar operaciones relacionadas con formas geom√©tricas
const GeometryModule = (function() {
    // Funci√≥n para calcular el √°rea de un c√≠rculo
    function calculateCircleArea(radius) {
        return Math.PI * radius ** 2;
    }

    // Funci√≥n para calcular el per√≠metro de un c√≠rculo
    function calculateCirclePerimeter(radius) {
        return 2 * Math.PI * radius;
    }

    // Funci√≥n para calcular el √°rea de un rect√°ngulo
    function calculateRectangleArea(length, width) {
        return length * width;
    }

    // Funci√≥n para calcular el per√≠metro de un rect√°ngulo
    function calculateRectanglePerimeter(length, width) {
        return 2 * (length + width);
    }

    // Exponer las funciones p√∫blicas del m√≥dulo
    return {
        calculateCircleArea,
        calculateCirclePerimeter,
        calculateRectangleArea,
        calculateRectanglePerimeter
    };
})();

// Uso del m√≥dulo de geometr√≠a
console.log(GeometryModule.calculateCircleArea(5)); // Output: 78.53981633974483
console.log(GeometryModule.calculateRectanglePerimeter(4, 6)); // Output: 20

---

// M√≥dulo con baja cohesi√≥n
const LowCohesionModule = (function() {
    // Funci√≥n para calcular el √°rea de un c√≠rculo
    function calculateCircleArea(radius) {
        return Math.PI * radius ** 2;
    }

    // Funci√≥n para convertir un n√∫mero a binario
    function decimalToBinary(number) {
        return number.toString(2);
    }

    // Funci√≥n para generar un n√∫mero aleatorio
    function generateRandomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    // Funci√≥n para validar un correo electr√≥nico
    function validateEmail(email) {
        return /\S+@\S+\.\S+/.test(email);
    }

    // Exponer las funciones p√∫blicas del m√≥dulo
    return {
        calculateCircleArea,
        decimalToBinary,
        generateRandomNumber,
        validateEmail
    };
})();

// Uso del m√≥dulo de baja cohesi√≥n
console.log(LowCohesionModule.calculateCircleArea(5)); // Output: 78.53981633974483
console.log(LowCohesionModule.decimalToBinary(10)); // Output: "1010"
console.log(LowCohesionModule.generateRandomNumber(1, 100)); // Output: un n√∫mero aleatorio entre 1 y 100
console.log(LowCohesionModule.validateEmail("example@example.com")); // Output: true
```

<a id="cod38"></a>

### **Uso de numeros magicos en lugar de constantes**

[Volver al indice](#cod-base)

Se deben pasar numeros que no se sabe que son como en el primer caso a constantes, como sucede en su segunda refactorizacion.

```javascript
public Double getAnnualSalary() {
    return 200.0 * 0.6..
}

public Double getAnnualSalary() {
    return WORKING_DAYS * WORKING_HOURS_PER_DAY...
}
```

<a id="cod39"></a>

### **Qu√© es la Programaci√≥n orientada a Objetos?**

[Volver al indice](#cod-base)

En ella las instrucciones tratan de modelar un sistema con base en la realidad, haciendo m√°s cercanos los conceptos que vemos en ella. Es por eso que en la programaci√≥n orientada a objetos aparecen conceptos de clase, objeto, atributo, m√©todo, etc., que en el fondo no dejan de ser bloques de c√≥digo. Asimismo, cabe notar que tambi√©n hacen uso de estructuras de control y repetici√≥n.

<a id="cod40"></a>

### **Qu√© es la programaci√≥n procedural?**

[Volver al indice](#cod-base)

En ella las imposiciones o instrucciones se pueden agrupar en ‚Äúprocedimientos‚Äù. Cada procedimiento es un bloque (la programaci√≥n procedural es una forma de programaci√≥n estructurada) que se dedica a un cambio de una parte espec√≠fica del estado del sistema. Estos bloques son conocidos t√≠picamente como ‚Äúfunciones‚Äù o ‚Äúsubrutinas‚Äù

<a id="cod41"></a>

### **Qu√© es la programacion declarativa?**

[Volver al indice](#cod-base)

Los lenguajes declarativos, en el paradigma declarativo de programaci√≥n, se utilizan para describir la estructura del sistema y describir qu√© hace el sistema. Una vez descrita ‚Äúla misi√≥n‚Äù del programa, el c√≥mo se llega al resultado depende de la implementaci√≥n interna del propio lenguaje.
Generalmente, se define a la programaci√≥n declarativa como ‚Äúno-imperativa‚Äù. Es decir, es todo lo que la imperativa no es. En este sentido, la programaci√≥n declarativa dice qu√© debe hacer el sistema, en donde la ejecuci√≥n no afecte otras partes del sistema y pueda representarse como una serie de premisas matem√°ticas (funciones/transformaciones). En un lenguaje imperativo, entonces, el sistema pasar√° de un estado a otro ejecutando una serie de pasos, un algoritmo. En un lenguaje declarativo se debe describir el estado inicial, el estado final y luego el propio motor del lenguaje har√° todo lo necesario para ir de un estado al otro
El ejemplo m√°s claro de un lenguaje declarativo es SQL. En SQL se describe qu√© informaci√≥n debe extraerse de una o m√°s tablas, sin control sobre la forma de obtenerlo. C√≥mo se obtiene lo maneja el motor de la base. Otro ejemplo ubicuo es HTML. En HTML se describe, por ejemplo, que debe existir cierto texto, centrado y en negrita, sin especificar ning√∫n tipo de l√≥gica ni control de flujo. C√≥mo es que veremos el texto centrado y en negrita depender√° de cada navegador

<a id="cod42"></a>

### **Que es la Programacion Imperativa?**

[Volver al indice](#cod-base)

Los lenguajes imperativos definen al paradigma imperativo de programaci√≥n. En este paradigma se usa el lenguaje para describir c√≥mo cambia el estado del sistema.

T√≠picamente, hay instrucciones (imposiciones) ordenadas en forma de l√≠neas de texto, una debajo de la otra, que se ejecutan de forma secuencial. El lenguaje imperativo describe c√≥mo opera el sistema.

La programaci√≥n imperativa es la m√°s ‚Äúnatural‚Äù, dado que surge desde el mism√≠simo hardware, donde se ejecuta instrucciones de m√°quina. Estas instrucciones, en su m√°s bajo nivel, mueven registros de datos de un lugar a otro, alteran valores, etc. Es decir, cambian el estado de los integrados, de la memoria, del procesador, en fin, de nuestra computadora. A medida que subimos de nivel, los lenguajes siguen haciendo lo mismo, solo que con estructuras m√°s complejas como variables, instrucciones complejas (como bucles, modificadores de visibilidad, e incluso cosas m√°s complejas como las anotaciones).

Ejemplos de lenguajes imperativos hay muchos: C, C++, Java, Perl y un infinito etc√©tera. En todos estos lenguajes se escriben l√≠neas de c√≥digo que describen los pasos de una algoritmo para lograr un resultado.

<a id="cod43"></a>

### **Qu√© es la Programacion Estructurada?**

[Volver al indice](#cod-base)

En ella las imposiciones se ven divididas en estructuras. Pueden ser estructura de control de flujo (if/else), de repeticiones (for/while) o pueden ser estructuras de ordenamiento(bloques de c√≥digo, generalmente delimitados por TABs o por llaves o corchetes)

<a id="cod44"></a>

### **Que es un antipatron?**

[Volver al indice](#cod-base)

Un antipatr√≥n de dise√±o es una implementaci√≥n que invariablemente conduce a una mala soluci√≥n. Al documentarse junto con los patrones de dise√±o, se dan argumentos para no escoger malos caminos en lugar de simplemente usar la intuici√≥n y el sentido com√∫n.
El t√©rmino se origina inspirado en el libro Design Patterns, el libro Anti-Patterns describe los antipatrones como la contrapartida natural al estudio de los patrones de dise√±o.
El estudio formal de errores que se repiten permite reconocer y reconducir los elementos involucrados hacia una mejor soluci√≥n. Los antipatrones no se mencionan en el libro original de Design Patterns, puesto que √©ste es anterior.
Los antipatrones se consideran una parte importante de una buena pr√°ctica de programaci√≥n. Es decir, un buen programador procurar√° evitar los antipatrones siempre que sea posible, lo que requiere su reconocimiento e identificaci√≥n tan pronto como sea posible, dentro del ciclo de vida del software.
El concepto se puede aplicar a la ingenier√≠a en general, e incluso a cualquier tarea realizada por el hombre. Aunque no se escucha con frecuencia fuera del campo ingenieril, la noci√≥n est√° ampliamente extendida.

<a id="cod45"></a>

### **Que tipos de antipatrones para el dise√±o de Software existen?**

[Volver al indice](#cod-base)

- **Base de datos como comunicador de procesos (Database as IPC)**: Es cuando usamos una base de datos para comunicar procesos para uno o varias m√°quinas, en lugar de hacer una comunicaci√≥n entre procesos directa (que es m√°s adecuada).
- **Objeto todopoderoso (BLOB Object)**: Simple, cuando hacemos que toda la funcionalidad se haga en un solo objeto (aplicable tambi√©n a cualquier tipo de componente).
- **Clase Gorda (Fat class)**: Es la que le sigue a la anterior, se trata de dotar a una clase con demasiados atributos y/o m√©todos, haci√©ndola responsable l√≥gicas de negocio que no les correspondan
- **Bot√≥n m√°gico (Magic Push-button)**: Se trata de desarrollar l√≥gica de negocio en los m√©todos de interacci√≥n de pantallas de usuario.
- **Carrera de obst√°culos (Race Hazard)**: Incapacidad de prever las consecuencias de diferentes sucesiones de eventos. En otras palabras es no tener visi√≥n o trazabilidad de la l√≥gica que se dispara en cada evento.
- **Entrada chapuza (Input Kludge)**: No especificar e implementar el manejo de entradas inv√°lidas. En otras palabras, es cuando no validamos los datos que entran al sistema.
- **F√°brica de combustible (Gas Factory)**: Dise√±ar de manera innecesariamente compleja. Dicho de otro modo, sobre modelar, dise√±ar por dem√°s, dise√±ar funcionalidad que no sabremos cuando.
- **Gran bola de lodo (Big Ball of Mud)**: Construir un sistema sin estructura definida. Sin una estructura la implementaci√≥n se desmorona.
- **Interfaz inflada (Interface Bloat)**: Pretender que una interfaz sea tan potente que resulta extremadamente dif√≠cil de implementar.
- **Punto de vista ambiguo (Ambiguous Viewpoint)**: Presentar un modelo sin concretar ciertos aspectos, postergando as√≠ decisiones conflictivas para m√°s adelante.
- **Re-dependencia (Re-coupling)**: Introducir dependencias ( o relaciones entre objetos) innecesarias.
- **Sistema de ca√±er√≠as de calefacci√≥n (Stovepipe System)**: Construir un sistema dif√≠cilmente mantenible, ensamblando componentes poco relacionados.

<a id="cod46"></a>

### **Que tipos de Antipatrones para el Dise√±o Orientado a Objetos existen?**

[Volver al indice](#cod-base)

- **Acoplamiento secuencial (Sequential coupling)**: Construir una clase que necesita que sus m√©todos se invoquen en un orden determinado o secuencia.
- **Base Bean**: Heredar funcionalidad de una clase utilidad en lugar de delegar lo que se necesite en ella.
- **Fallo de clase vac√≠a (Empty Subclass Failure)**: Crear una clase que no supera el test de la subclase vac√≠a, es decir, que se comporta de manera diferente cuando se invoca desde una subclase que no a√±ade modificaci√≥n o funcionalidad alguna.
- **Llamar a Super (Call Super)**: Obligar a las subclases a llamar a un m√©todo de la superclase que ha sido sobrescrito.
- **Modelo de dominio An√©mico (Anemic Domain Model)**: Usar un modelo del dominio sin ninguna l√≥gica de negocio que de valor. Esto no es un enfoque orientado a objetos porque cada objeto deber√≠a tener tanto propiedades como comportamiento asociado espec√≠fico (que haga transformaciones) y no solo para llevar datos desde la base a la pantalla.
- **Objeto Sumidero (Object Cesspool)**: Reusar objetos no adecuados realmente para el fin que se persigue.
- **Poltergeist**: Emplear objetos cuyo √∫nico prop√≥sito es pasar la informaci√≥n a terceros objetos sin aportar valor o realizar transformaciones.
- **Problema del c√≠rculo-elipse (circle-ellipse problem)** : Crear variables de tipo pensando en los valores de posibles subtipos, generando problemas de bifurcaciones l√≥gicas que no son predecibles.
- **Problema del yoy√≥ (yo-yo problem)**: Construir estructuras (por ejemplo de herencia) que son dif√≠ciles de comprender debido a su excesiva fragmentaci√≥n.
- **Singletonitis**: Abuso de la utilizaci√≥n del patr√≥n singleton. Este concepto es tambi√©n aplicable a cualquier tipo de patr√≥n de dise√±o en el que se abuse de su implementaci√≥n en lugares no adecuados o necesarios. Suele ocurrir con programadores con poca experiencia
- **YAFL (‚Äúyet another layer‚Äù u otra capa m√°s no deseada)**: Se trata de a√±adir capas innecesarias a un programa, sub-programa, biblioteca o framework. Esta tendencia se extendi√≥ bastante despu√©s de que se publicase el primer libro sobre patrones.

<a id="cod47"></a>

### **Singleton**

[Volver al indice](#cod-base)

Obliga a que exista solo un objeto de un tipo. Se puede usar para crear un objeto que se encargue de la conexi√≥n a una base de datos, para que no se creen m√∫ltiples conexiones.

```javascript
class Singleton {
    constructor() {
        // Si la instancia no existe, se crea
        if (!Singleton.instance) {
            Singleton.instance = this;
        }

        // Si no, se devuelve lo que ya existe
        return Singleton.instance;
    }
}

const singleton = new Singleton();
const singleton2 = new Singleton(); // Devuelve la misma instancia
```

<a id="cod48"></a>

### **Que es el Polimorfismo?**

[Volver al indice](#cod-base)

Conocido tambi√©n como ***ligadura din√°mica***, ***ligadura tard√≠a*** (***late binding***), el concepto fundamental del ***Polimorfismo*** es ‚Äúmismo mensaje, distinta implementaci√≥n‚Äù y consiste en implementar o reemplazar el m√©todo de una clase con otro m√©todo llamado exactamente igual pero escrito en otra clase (derivada de la primera).

Para que se produzca esta ligadura tard√≠a (que efectivamente se produce **en *tiempo de ejecuci√≥n***, cuando el objeto es asignado a la variable) se requieren algunas cosas:

- Que las clase implicadas tengan declarado (y directa o indirectamente implementado) un m√©todo con ***exactamente la misma firma***.
- Que la variable que guarde el objeto sea de la clase de ***mayor jerarqu√≠a*** entre las todas las implicadas (la que todos los objetos posibles tengan en com√∫n).
- Que no se trate de un m√©todo *de clase* (***static***).
- Que no se trate de un m√©todo privado (porque no se puede heredar).
- Que no haya sido declarado como ***final***, porque no podr√° ser definido.

Si se cumplen estos requisitos, usando **siempre la misma *llamada* o *invocaci√≥n***¬† y**sea cual sea el objeto asignado**, **la variable declarada expondr√°** a trav√©s de su*capa de abstracci√≥n* o *API* (*application programming interface*, o *interfaz de acceso program√°tico*) ***distinta implementaci√≥n***. As√≠, cuando una variable que contiene una instancia propia o de cualquiera de sus subclases invoca a un m√©todo, la versi√≥n del m√©todo que se ejecutar√° no ser√° necesariamente la que figura en la clase de la variable declarada, sino la existente en la clase de la instancia referida por la variable. Dicho de otra manera, **la versi√≥n del m√©todo que ser√° ejecutada depende de la clase del objeto referenciado, no de la variable que lo referencia**.

El polimorfismo es una de las principales aplicaciones de la herencia y supone el principal motivo de las clases abstractas

En POO polimorfismo se refiere a la propiedad por la que es posible enviar mensajes sint√°cticamente iguales a objetos de distinta clase

El √∫nico requisito que deben cumplir los objetos que se utilizan de manera polim√≥rfica es saber responder al mensaje que se les env√≠a

Para que el objeto pueda responder al mensaje, la clase debe contener el m√©todo (mensaje)

Para garantizar que dos clases distintas contengan el  mismo m√©todo, debemos hacer que estas  lo hereden de una clase superior

En el ejemplo de los pol√≠gonos, creamos una clase abstracta Poligono con un m√©todo abstracto obtenerSuperficie(). Este m√©todo no tiene implementaci√≥n en la clase Poligono porque cada pol√≠gono tiene su propia f√≥rmula para calcular la superficie, pero al declarar el m√©todo, establecemos un contrato que asegura que cualquier subclase de Poligono tendr√° que implementar su propio c√°lculo de superficie. De esta forma, logramos que cada subclase, como Cuadrado, Triangulo o Circulo, implemente su c√°lculo espec√≠fico de superficie, usando polimorfismo para permitir diferentes comportamientos en una misma estructura.

<a id="cod49"></a>

### **Que es el Upcasting?**

[Volver al indice](#cod-base)

Es la posibilidad de tratar a un objeto de una subclase como un objeto de la superclase.

Esto se logra apuntando a un objeto de una subclase con un puntero de su superclase.

```jsx
Perro fido;
Mascota a;
fido = new Perro("Fido", "Bull Dog");
a = fido;
```

Tras la conexi√≥n polimorfa √∫nicamente podemos acceder a los atributos y m√©todos pertenecientes a la clase asociada a la referencia

<a id="cod50"></a>

### **Que es el Downcasting?**

[Volver al indice](#cod-base)

Es la posibilidad de volver a tratar el objeto con un puntero a la clase a la que pertenece

Se utiliza para volver a acceder a todos los atributos y m√©todos del mismo

A diferencia del upcasting, siempre se hace indicando cual es la subclase

```jsx
Perro fido;
Mascota a;
Perro  mismoFido;

fido = new Perro("Fido",
               "Bull Dog");
a = fido;
mismoFido = (Perro) a;
```

Es posible que al hacer un downcasting se produzca un error debido a que la clase a la que pertenezca el objeto no coincida con la clase del puntero.

Para evitarlo podemos utilizar la instrucci√≥n de Java instanceof.

```jsx
if (a instanceof Perro)
      mismoFido = (Perro) a;
```

<a id="cod51"></a>

### **¬øC√≥mo se produce la ligadura tard√≠a y din√°mica que posibilita el polimorfismo?**

[Volver al indice](#cod-base)

Gracias a los punteros o referencias: cuando se crea una variable el lenguaje registra en una lista interna cada m√©todo declarado para esa clase y espera a que se ‚Äúguarde‚Äù un objeto en la variable a trav√©s de una asignaci√≥n. Cuando se produce la asignaci√≥n del objeto, se recorre internamente la lista de m√©todos de la declarados en la variable que pueden ser sobreescritos y se compara con los m√©todos disponibles para el objeto (propios o heredados). Si la firma coincide, el m√©todo encontrado en el objeto asignado se asociar√° a la declaraci√≥n existente y sobreescribir√° la referencia y sustituir√° el enlace al m√©todo original, si √©ste estaba implementado.

<a id="cod52"></a>

### **El Principio de Sustituci√≥n de Liskov**

[Volver al indice](#cod-base)

El ***Principio de Sustituci√≥n de Liskov*** fue acu√±ado por **Barbara Liskov** en 1987 durante una conferencia sobre *Jerarqu√≠a y Abstracci√≥n de datos*. Este principio dice que al sobreescribir un m√©todo se debe asegurar que √©ste mantenga el esp√≠ritu original del m√©todo, sin alterar ni dejar de cumplir la premisa o responsabilidad declarada inicialmente para el mismo. Seg√∫n este principio, **una clase derivada no √∫nicamente *es*, sino que *debe comportarse* como la clase base**. Por ejemplo, si hay un m√©todo *abrirPuerta()*, una clase derivada no deber√≠a hacer que su *abrirPuerta()* abra las ventanas, o prenda la radio. A nivel declarativo y de programaci√≥n puede estar perfecto, pero no ser√≠a correcto. Puede tener otra forma de abrir la puerta, pero no hacer otra cosa.

<a id="cod53"></a>

### **¬øC√≥mo ejemplificar√≠as el uso de polimorfismo en Java usando una colecci√≥n de objetos?**

[Volver al indice](#cod-base)

En Java, el polimorfismo se puede ver claramente al trabajar con una colecci√≥n de objetos que comparten una clase base. En este ejemplo, creamos una lista ArrayList<Poligono> y agregamos instancias de Cuadrado, Triangulo y Circulo. Cuando recorremos esta colecci√≥n, llamamos al m√©todo obtenerSuperficie() de cada pol√≠gono, y cada uno calcula su superficie utilizando su propia implementaci√≥n del m√©todo. As√≠, aunque estamos llamando al mismo m√©todo, el comportamiento es diferente seg√∫n el tipo espec√≠fico de pol√≠gono:

```java
ArrayList<Poligono> poligonos = new ArrayList<>();
poligonos.add(new Cuadrado("#FF0000", 50));
poligonos.add(new Triangulo("#00FF00", 50, 50));
poligonos.add(new Circulo("#0000FF", 25));

for (Poligono poligono : poligonos) {
    System.out.printf("%s Superficie=%f\n", poligono, poligono.obtenerSuperficie());
}
```

<a id="cod54"></a>

### **Qu√© es la densidad de codigo?**

[Volver al indice](#cod-base)

La densidad de c√≥digo es una m√©trica que mide la cantidad de c√≥digo fuente en un programa en relaci√≥n con la cantidad de comentarios y l√≠neas en blanco. Se utiliza para evaluar la legibilidad y mantenibilidad del c√≥digo, ya que un c√≥digo con una alta densidad de c√≥digo puede ser dif√≠cil de entender y modificar.

**Densidad Horizontal**

Mismo concepto pero de manera horizontal, entre caracteres

DON¬¥T

```java
public Integer tripleSum(Integer a, Integer b, Integer c){
   if (a==null||b==null||c==null){
       return null;
   }
   return a+b+c;
}
```

DO

```java
public Integer tripleSum(Integer a, Integer b, Integer c) {
   if (a == null || b == null|| c == null){
       return null;
   }
   return a + b + c;
}
```

<a id="cod55"></a>

### **La importancia del orden de las funciones**

[Volver al indice](#cod-base)

El orden de las funciones es para facilitar la lectura. En el ejemplo, primero ponemos la funcion¬†`a()`¬†que a su vez, consume a¬†`b()`¬†y¬†`c()`, haciendo que la lectura sea ordenada.

```
public void a(){
    b();
    c();
}public void b(){}public void c(){}
```

<a id="cod56"></a>

### **Porque se deberia evitar retornar null?**

[Volver al indice](#cod-base)

- No se debe devolver null en una funcion
- Al devolver null, obligamos que se chequee ese null, es una gran fuente de bugs, por ejemplo, es recomendable devolver una lista vacia en vez de un null
- No debemos pasar null en los parametros de una funcion, obligamos a que se chequee que estos parametros no sean nulos para ejecutar correctamente.

DON'T

```jsx
public void processRequestBatch() {
  List<Request> requestList = getRequestList();
  if (requestList != null) {
    for (Request r: requestList) {
      processRequest(r);
    }
  }
}
```

DO

```jsx
public void processRequestBatch(){
  List<Request> requestList = getRequestList();
  for (Request r: requestList) {
    processRequest(r);
  }
}
```

<a id="cod57"></a>

### **Porque se deberia evitar el uso de variables globales?**

[Volver al indice](#cod-base)

- Las variables globales pueden ser modificadas por cualquier parte del c√≥digo, lo que puede llevar a errores dif√≠ciles de rastrear.
- Las variables globales pueden ser accedidas por cualquier parte del c√≥digo, lo que puede llevar a dependencias no deseadas.
- Las variables globales pueden ser dif√≠ciles de depurar y mantener, ya que su alcance es global y no est√° claro d√≥nde se utilizan o modifican.
- Las variables globales pueden causar problemas de concurrencia si se acceden y modifican desde m√∫ltiples hilos de ejecuci√≥n.
- Las variables globales pueden dificultar la reutilizaci√≥n del c√≥digo, ya que las dependencias globales pueden hacer que sea dif√≠cil separar las partes del c√≥digo en m√≥dulos independientes.

<a id="cod57-1"></a>

### **¬øC√≥mo podr√≠as mejorar la calidad del c√≥digo en un proyecto en marcha?**

[Volver al indice](#cod-base)

Mejorar la calidad del c√≥digo en un proyecto en marcha requiere un enfoque estructurado y progresivo para no afectar la funcionalidad existente mientras se mejora la base del proyecto. Aqu√≠ hay varias estrategias que puedes seguir:


### **1. Evaluaci√≥n inicial y establecimiento de objetivos**
- **Auditor√≠a del c√≥digo existente:** Revisa el c√≥digo base para identificar problemas comunes como:
  - C√≥digo duplicado.
  - Nombres de variables poco descriptivos.
  - Falta de pruebas unitarias.
  - Ciclos de vida complejos o dif√≠ciles de seguir.
- **Definir est√°ndares:** Establece o actualiza las gu√≠as de estilo (por ejemplo, est√°ndares para nombres, estructura de carpetas, o uso de patrones).
- **Objetivos progresivos:** Define metas alcanzables, como mejorar la cobertura de pruebas al 80% o reducir el tiempo de carga en un 20%.

---

### **2. Limpieza y refactorizaci√≥n del c√≥digo**
- **Refactorizaci√≥n progresiva:**
  - Identifica m√≥dulos o componentes cr√≠ticos y refactor√≠zalos uno a la vez.
  - Aplica principios SOLID para mejorar la modularidad y legibilidad.
  - Usa patrones de dise√±o (como Factory, Singleton o Strategy) si simplifican el c√≥digo.
- **Eliminar c√≥digo muerto:** Identifica funciones, componentes o estilos que ya no se usan y elim√≠nalos.
- **Simplificaci√≥n de funciones:** Divide funciones complejas en funciones m√°s peque√±as y reutilizables.

*Ejemplo de refactorizaci√≥n:*

C√≥digo inicial:
```javascript
function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    if (items[i].type === 'discounted') {
      total += items[i].price * 0.9;
    } else {
      total += items[i].price;
    }
  }
  return total;
}
```

C√≥digo refactorizado:
```javascript
function calculateItemPrice(item) {
  return item.type === 'discounted' ? item.price * 0.9 : item.price;
}

function calculateTotal(items) {
  return items.reduce((total, item) => total + calculateItemPrice(item), 0);
}
```

---

### **3. Implementaci√≥n de pruebas**
- **Pruebas unitarias y de integraci√≥n:**
  - Usa herramientas como Jest, Jasmine o Mocha para asegurar la calidad de cada m√≥dulo.
  - Prioriza las √°reas del c√≥digo con mayor probabilidad de errores o que se usan frecuentemente.
- **Pruebas automatizadas:**
  - Usa herramientas como Selenium, Cypress o Playwright para automatizar pruebas funcionales y de interfaz.
- **Cobertura de pruebas:** Implementa herramientas como Istanbul para monitorear la cobertura de pruebas y mantener est√°ndares altos.

---

### **4. Optimizaci√≥n del rendimiento**
- **An√°lisis de rendimiento:**
  - Mide la velocidad del renderizado, el uso de memoria, y el tama√±o de los bundles.
  - Usa herramientas como Lighthouse, Webpack Bundle Analyzer o DevTools.
- **Lazy loading y tree shaking:** Implementa carga diferida para recursos pesados y elimina c√≥digo no utilizado en los bundles.
- **Optimizaci√≥n de la red:** Reduce las peticiones HTTP, habilita compresi√≥n (gzip/brotli) y usa HTTP/2 o HTTP/3.

---

### **5. Automatizaci√≥n de tareas repetitivas**
- **Linting y formateo:** Usa ESLint y Prettier para mantener la consistencia en el c√≥digo.
- **Integraci√≥n continua (CI/CD):**
  - Configura pipelines con herramientas como Jenkins, GitHub Actions, o GitLab CI para automatizar pruebas, linting y despliegues.
- **Revisi√≥n automatizada de c√≥digo:** Implementa bots como Dependabot para gestionar dependencias y Snyk para detectar vulnerabilidades.

---

### **6. Mejora de documentaci√≥n**
- **Comentarios efectivos:** Escribe comentarios para explicar el "por qu√©" de decisiones complejas, no el "c√≥mo".
- **Documentaci√≥n del proyecto:** Usa herramientas como Storybook para documentar componentes UI o Swagger/OpenAPI para APIs.
- **README claro:** Aseg√∫rate de que el README tenga instrucciones claras sobre c√≥mo ejecutar, probar y desplegar el proyecto.

---

### **7. Capacitaci√≥n y revisi√≥n de c√≥digo**
- **Revisi√≥n por pares:** Implementa pull requests obligatorios para garantizar que cada cambio pase por al menos una revisi√≥n.
- **Capacitaci√≥n del equipo:** Organiza talleres para ense√±ar nuevas herramientas, patrones o buenas pr√°cticas.

---

### **8. Monitoreo continuo**
- **Seguimiento de errores:** Usa herramientas como Sentry o LogRocket para detectar y solucionar problemas en producci√≥n.
- **M√©tricas de calidad:** Monitorea m√©tricas como el tiempo de respuesta, n√∫mero de bugs reportados y cumplimiento de est√°ndares.

<a id="cod57-2"></a>

### **Si tienes plazos ajustados y te ves obligado a escribir "mal c√≥digo", ¬øc√≥mo manejar√≠as esa situaci√≥n?**

[Volver al indice](#cod-base)

Cuando te enfrentas a plazos ajustados y necesitas priorizar la entrega sobre la calidad del c√≥digo, es importante abordar la situaci√≥n de manera estrat√©gica para minimizar el impacto a largo plazo.


### **1. Planificaci√≥n y comunicaci√≥n temprana**
- **Habla con el equipo o stakeholders:**
  - Informa que, para cumplir con el plazo, es posible que se comprometa la calidad del c√≥digo.
  - Explica los riesgos de acumular deuda t√©cnica, como mayor dificultad de mantenimiento, bugs futuros, y tiempo extra para agregar nuevas funcionalidades.
  - Prop√≥n un plan para abordar esa deuda t√©cnica despu√©s del plazo.

  *Ejemplo:*
  "Podemos cumplir con la fecha l√≠mite, pero algunos aspectos del c√≥digo ser√°n soluciones temporales. Despu√©s de la entrega, necesitaremos tiempo para refactorizar y mejorar la calidad del c√≥digo para evitar problemas futuros."


### **2. Mant√©n un enfoque m√≠nimo viable**
- **Define el alcance exacto:** Limita las funcionalidades al n√∫cleo imprescindible para cumplir con los objetivos. Recorta caracter√≠sticas secundarias que puedan ser agregadas m√°s tarde.
- **Prototipos r√°pidos:** En lugar de implementar una soluci√≥n perfecta, crea una soluci√≥n funcional que cumpla los requisitos m√≠nimos.

  *Ejemplo:* Si est√°s desarrollando una funcionalidad de b√∫squeda, inicialmente podr√≠as implementar una b√∫squeda b√°sica sin filtros avanzados ni ordenaci√≥n sofisticada.


### **3. Escribe "c√≥digo malo" de manera controlada**
Si escribir "c√≥digo malo" es inevitable, sigue estas pr√°cticas para minimizar el da√±o:

- **Documenta las √°reas d√©biles:**
  - A√±ade comentarios en el c√≥digo para se√±alar qu√© partes necesitan refactorizaci√≥n o tienen l√≥gica temporal.
  - Usa palabras clave como `// TODO` o `// FIXME` para que sean f√°cilmente identificables.

  ```javascript
  // FIXME: Optimizar esta funci√≥n para manejar casos con grandes cantidades de datos.
  function processData(data) {
    return data.map(item => heavyComputation(item));
  }
  ```

- **Evita la propagaci√≥n del mal c√≥digo:**
  - Restringe las soluciones r√°pidas a un √°rea espec√≠fica del sistema.
  - Encapsula la l√≥gica temporal en m√≥dulos o funciones que puedas reemplazar f√°cilmente m√°s adelante.

  ```javascript
  // Soluci√≥n temporal para c√°lculo de descuentos
  function calculateDiscount(price) {
    return price * 0.9; // TODO: implementar l√≥gica avanzada con reglas din√°micas
  }
  ```

- **Pruebas b√°sicas:** Aunque sea un c√≥digo r√°pido, incluye al menos pruebas m√≠nimas para asegurarte de que funciona correctamente.


### **4. Prioriza la deuda t√©cnica m√°s cr√≠tica**
- **Crea un backlog de deuda t√©cnica:** Lleva un registro claro de todas las √°reas donde el c√≥digo requiere mejoras, priorizando seg√∫n el impacto.
- **Asigna tiempo post-entrega:** Programa un sprint t√©cnico despu√©s de cumplir con el plazo para refactorizar el c√≥digo.


### **5. Evita problemas comunes del "c√≥digo malo"**
Incluso bajo presi√≥n, sigue estas pr√°cticas para evitar errores desastrosos:
- **No omitas validaciones:** Aseg√∫rate de manejar errores, incluso con soluciones simples.
- **Usa nombres significativos:** No sacrifiques claridad; el c√≥digo mal estructurado no tiene que ser ilegible.
- **Evita dependencias r√≠gidas:** Aseg√∫rate de que las soluciones r√°pidas no bloqueen la integraci√≥n de futuras funcionalidades.

  *Ejemplo de mala pr√°ctica:*
  ```javascript
  // Hardcode que ser√° dif√≠cil de mantener
  const API_URL = "http://localhost:3000/api/v1/products";
  ```

  *Mejor alternativa:*
  ```javascript
  // Define constantes para permitir configuraciones futuras
  const API_URL = process.env.API_URL || "http://localhost:3000/api/v1/products";
  ```


### **6. Post-entrega: Paga tu deuda t√©cnica**
Despu√©s de cumplir el plazo:
- **Revisa el c√≥digo:** Eval√∫a las partes comprometidas y refact√≥ralas.
- **Incrementa la cobertura de pruebas:** Agrega pruebas unitarias y de integraci√≥n para las √°reas con c√≥digo temporal.
- **Aprende de la experiencia:** Analiza qu√© caus√≥ el plazo ajustado y ajusta los procesos (como planificaci√≥n o estimaciones) para evitar futuras situaciones similares.

Aunque no es ideal escribir "mal c√≥digo," puedes minimizar el impacto con documentaci√≥n, encapsulaci√≥n, y planificaci√≥n. Siempre prioriza una refactorizaci√≥n inmediata despu√©s de cumplir con los plazos. Esto garantizar√° que el proyecto siga siendo mantenible y escalable en el futuro.

<a id="cod58"></a>

### **¬øQu√© es un Code Smell?**

[Volver al indice](#cod-base)

Son sintomas de que el codigo no es todo lo limpio que deberia. Hay distintos tipos de code smells como:

- En los comentarios
- En el entorno de desarrollo
- En las funciones
- Code Smells Generales
- Code Smells en Java u otros lenguajes
- En los nombres
- En los tests

Nadie se va a volver experto teniendo esta lista de memoria, nunca va a ser una lista completa de todos los problemas que puede tener el c√≥digo.

<a id="cod59"></a>

### **Code Smells en los Tests**

[Volver al indice](#cod-base)

**Tests insuficientes** Se deben probar todas las posibilidades de una funcion. Si no se prueban todas las condiciones, los tests son insuficientes.

**No usar una herramienta de cobertura** Se muestran claramente las lineas que no estan siendo cubiertas por los tests. Son faciles de instalar.

**Evitar los tests triviales** Aunque una funcionalidad parezca trivial, hacer un test igual. Es una gran fuente de bugs.

**Test ignorado o comentado** Segun Robert C. Martin ‚ÄúA veces tenemos dudas sobre los detalles de una funcionalidad, porque los requisitos no est√°n claros. Podemos expresar estas dudas con un test comentado, o con un test con¬†`@ignore`. La opcion que elijas depende de si tu test compila o no"

Si hay dudas en los tests, hay dudas en los requisitos

**No testear condiciones limite** Son los mayores generadores de bugs, hay que testearlos. No solo testear las condiciones normales del c√≥digo.

**No buscar bugs de forma exhaustiva** Los bugs tienden a estar cerca unos de otros. Si encontr√°s un bug, revisar, pueden haber m√°s.

**Los patrones de fallo son reveladores** Si vemos que una funcion falla cuando mandamos un String con caracteres en blanco, debemos manejar esto.

**La cobertura de codigo es reveladora** Se pueden encontrar los motivos de fallo con las lineas que no estan analizadas

**Los tests deben ser r√°pidos** Si los tests tardan mucho, no se van a correr. Deben ser r√°pidos para que se corran seguido.

<a id="cod60"></a>

### **Code Smells en Codigo**

[Volver al indice](#cod-base)

**Mezclar muchos lenguajes en un solo fichero** En el ejemplo podemos ver que se mezclan Java y HTML en un mismo archivo. A veces puede ser razonable (CSS + JS), pero en casos como el ejemplo, solo ensucia el codigo.

```java
public String getUserProfilePage (User user) {
  return "<html> <body>...."
}
```

**No usar variables explicatorias** Crear variables intermedias hace que el codigo quede mucho mas claro. Por ejemplo, en la imagen podemos ver la primera imagen que es una funcion de una sola linea, que queda mucho mas clara en su segunda version, agregando una variable intermedia para calcular un cateto.

```javascript
public Double calcularArea(Double hipotenusa, Double cateto) {
    return Math.sqrt(hipotenusa*hipotenusa - cateto*cateto) * cateto / 2;
}

public Double calcularArea (Double hipotenusa, Double cateto) {
    Double cateto_2 = Math.sqrt(hipotenusa*hipotenusa - cateto*cateto);

    return cateto * cateto_2 / 2;
}
```

No se debe sacrificar claridad por menos lineas.

**Duplicidad** Tener codigo repetido entre funciones y clases es algo com√∫n, es una oportunidad perdida para generar una nueva abstraccion. Si tenemos duplicidad entre varias clases, puede indicar la necesidad de una nueva jerarquia.
Ademas es dificil de mantener, ya que si cambiamos una parte de ese codigo, debemos repetirlo en todos los lugares en donde se encuentra.

**Demasiada Informaci√≥n** Poner demasiados metodos, demasiados get/set, etc, cuando no sabemos si hace falta. Los modulos bien definidos tienen interfaces muy peque√±as que permiten hacer mucho con pocos metodos.

- Exponer solo lo necesario
- Esconde los datos, ofrece operaciones, que no todo tenga get/set si no es necesario.

**C√≥digo Muerto** C√≥digo que no se usa debe ser eliminado. Por ejemplo:

- Funciones que no se llaman
- Condiciones en el switch/case que no se dan nunca, al igual que con el if
- try/catch con excepciones que nunca se lanzan

Se debe borrar sin miedo, Git recuerda todo.

**Basura** Son partes que no sirven de nuestro codigo, como por ejemplo:

- Constructores sin implementacion puestos por defecto
- Getters y Setters de todas las variables privadas de una clase que puede ser que no se usen nunca
- Variables y funciones que no se usan nunca

**Inconsistencia**

- Si haces algo de una forma, hacelo siempre de la misma forma, tanto nombre como logica
- Si, por ejemplo, se elije la palabra ‚Äúdelete‚Äù para eliminar algo, no cambiarlo en otro lado por ‚Äúremove‚Äù
- Esto hace que nuestro codigo sea mucho mas facil de leer para otros y para uno mismo

**Distancia Vertical** Las variables y funciones deben estar cerca de donde se usen

- Las variables locales deben ser declaradas antes de ser usadas
- Las funciones privadas deben estar debajo de la primera funcion que las usa
- No queremos que codigo local este puesto a muchas lineas de distancia de donde es usado ya que hace que sea complicado de leer

**Comportamiento obvio no implementado**

```
Month month = MonthDate.StringToMonth(String monthName);
```

Esperamos que esta funcion pase el parametro¬†`July`¬†a un enum¬†`Month.JULY`. Que haga lo mismo con¬†`jULY`¬†y¬†`july`, si el codigo no hace lo que se espera en estos casos, se pierde confianza en el, y se debe estar revisando lo que hace cada linea.


**Listas de imports muy largas** Si usas dos o mas clases de un paquete, importar directamente todo el paquete.

**Herencia de constante** Se debe evitar el uso de herencia para estos mecanismos. Por ejemplo¬†`Game`¬†hereda de¬†`GameConstants`. Se debe usar¬†`GameConstants.NUMBER_OF_LEVELS`¬†o importarlo directamente. No se debe usar herencia para crear estos mecanismos.

```jsx
public class EasyGame extends Game {
    private int currentLevel;
    public Double calculateProgress(){
        return currentLevel / NUMBER_OF_LEVELS;
    }
}

public abstract class Game implements GameConstants {
    public Double calculateProgress();
}

public interface GameConstants {
    public static final int NUMBER_OF_LEVELS = 10;
}
```

**Enums vs Constantes** Usar enums siempre y cuando sea posible. Es mas potente en funcionalidad y claridad. Tambien nos permiten declarar funciones abstractas para cada valor, como¬†`numberOfLevels`¬†por nivel.

```jsx
public class Game {
  private int currentLevel;
  DifficultyLevel difficultyLevel;

  public int levelsLeft() {
    return difficultyLevel.numberOfLevels() - currentLevel;
  }
}

public enum DifficultyLevel {
  EASY {
    public int numberOfLevels() {
      return 20;
    }
  },
  MEDIUM {
    public int numberOfLevels() {
      return 30;
    }
  },
  HARD {
    public int numberOfLevels(){
      return 50;
    }
  }

  public abstract int numberOfLevels();
}
```

Se evitan los condicionales por nivel de dificultad en el ejemplo.

<a id="cod61"></a>

### **Code Smells en Nombres**

[Volver al indice](#cod-base)

**Nombres en nivel de abstraccion incorrecto** Si tenemos una clase¬†`FtpFileDownloader`¬†que implementa la interfaz, ya no recibiria una web url.

```jsx
public interface FileDownloader {
  File download(String webUrl);
}
```

**No usar nomenclatura estandar**

- Por ejemplo, usar la palabra¬†`Singleton`¬†para clases que usen ese patr√≥n, la palabra¬†`Controller`¬†cuando se trata de un controlador, etc..
- Sobreescribir metodos¬†`toString`¬†que ya tienen las clases Java en lugar de crear un metodo propio. No reinventar la rueda

**No usar nombres largos para largos alcances** Se pueden usar nombres de pocos caracteres para alcances cortos, pero si el alcance es mayor, el nombre largo es necesario. El ejemplo de un alcance acotado es en el caso de¬†`i`¬†para un bucle.

```jsx
for (int i = 0; i < numberOfRequests; i++) {
  processRequest(requests.get(i));
}

// NOPE
public class Car {
  private int hp;
}

// SIP
public class Car {
  private int horsePower;
}
```

**Usar Codificaciones**

- Evitar los nombres con codificaciones que distraigan al lector
- Un ejemplo malo son las variables, por ejemplo¬†`intVariable`¬†o¬†`strName`. No es necesario agregar el prefijo¬†`str`¬†si ya se sabe que se trata de un String.

**Ocultar efectos secundarios** Si existen efectos secundarios, los nombres de las variables y funciones deben describirlo. Por ejemplo, en el caso de esta funcion¬†`login`, se hace mas de una cosa, y no es aclarado. Se debe separar en dos funciones o cambiar el nombre (recomendable la primera)

```jsx
public Boolean login (User user) {
    User databaseUser = userRepository.findByUsername(user.getUsername());

    if (validCredentials(user, databaseUser)) {
        return true;
    }

    // Esto esta de mas
    if (checkNumberOfTries(user.getIp()) > MAX_TRIES) {
        blockUser(user);
    }

    return false;

}
```

<a id="cod62"></a>

### **Code Smells en Comentarios**

[Volver al indice](#cod-base)

**Informacion Inapropiada** Todo comentario que contenga informacion que este mejor documentada en otro sistema debe ser movida.
Por ejemplo en este caso, el autor del codigo ya esta siendo registrado por Git, no es necesario que haya un comentario que lo indique, lo mismo con los TODO

DON¬¥T

```java
//@author Denisse Lemos
public class Comments {}
```

**Comentario Obsoleto** Los comentarios deben estar actualizados al codigo actual para que no confundan al programador.

**Comentario Redundante** Comentarios innecesarios de, por ejemplo, javadoc. Que no aportan valor al codigo

**Comentario mal redactado** Los comentarios utiles deben estar bien redactados, sin faltas de ortografia y directo.

**C√≥digo Comentado** Nunca dejar codigo comentado, ya que se guarda el registro de cambios en Git. El codigo que no se necesita, se borra.

<a id="cod63"></a>

### **Code Smells en el entorno**

[Volver al indice](#cod-base)

**Que la compilacion requiera mas de un paso** Se debe ser capaz de hacer un checkout del codigo fuente con un solo comando y compilarlo con otro solo comando. Si el codigo es simple y no tiene dependencias, es facil de hacer, pero a medida que va creciendo en dependencia, puede ser que se necesite compilar las dependencias por separado para luego compilar el proyecto, para esto se crearon muchas herramientas para automatizar el build del codigo. En Java el mas usado es Maven o Apache, en JS es Grunt, entre otros‚Ä¶

```
git clone {nuestroProyecto}
mvn install
```

**Los test requieren mas de un paso** Los test se deben ejecutar con un unico comando facil, rapido y obvio, al igual que la compilacion. Si esto no se cumple, pueden haber altas chances de que los test no suelan correrse por el trabajo que conllevan en si mismos. La idea es ejecutarlos muy seguido.
Tambien hay herramientas de automatizacion para los tests, con comandos especificos para los tests. En maven existe¬†`mvn test`

<a id="cod64"></a>

### **Code Smells en Funciones**

[Volver al indice](#cod-base)

**Demasiados parametros / argumentos** Las funciones mas faciles de leer son las que no reciben parametros. Mientras mas parametros, mayor es la complejidad. No se recomiendan mas de 3 parametros, y si es el caso, se recomienda refactorizar, separando esta funcion en varias funciones mas peque√±as o encapsulando los argumentos en una clase

**Intenciones ocultas dificiles de apreciar**

- El codigo debe ser lo mas expresivo posible
- De nada vale un codigo que ocupa poco espacio si no lo entendemos. Mejor aclarar lo mas posible antes que priorizar el ahorro de caracteres

En este ejemplo podemos ver que se ahorraron muchas letras en los nombres de las funciones, haciendo que sea muy confuso de leer

```javascript
public int otCalc(){
  return isWkn * wkRte + (int) Math.round(0.5 * wkRte * ...);
}
```

**Una funci√≥n recibe parametros de salida** Los argumentos de salida con los que se le pasan a una funcion para que esta guarde el resultado, en vez de usar un return, como en el caso del ejemplo el parametro¬†`int* result`, que solo sirve para guardar el resultado en una variable global. Siempre se debe usar el¬†`return`
Estos argumentos son muy usados en lenguajes como C.

```c
#include <stdio.h>

void suma (int input1, int input2, int* result) {
  *result = input1 + input2;
}

int main() {
  int result;
  suma(1,2,&result);
  printf("Result: %d\n", result);

  return 0;
}
```

**Comportamiento incorrecto en los limites del codigo** Muchos bugs del codigo estan en los limites de los condicionales o bucles de los codigos.

```java
private final List<String> thirtyOneDayMonths = Arrays.asList("January", "March", "May", "July", "August", "October", "December");

private final List<String> thirtyDayMonths = Arrays.asList("April", "June", "September", "November");

public int getNumberOfDaysInMonth(String month) {
  if (thirtyOneDayMonths.contains(month)) {
    return 31;
  }
  if (thirtyDayMonths.contains(month)) {
    return 30;
  }
  return 28;
}
```

Si un a√±o es biciesto, el codigo seria incorrecto

**No encapsular las condiciones limite** Las condiciones limite son los focos mas importantes de bug. Es importante encapsularlas bien y tenerlas bien definidas.
Si tenemos que definir una variable mas para que quede mas claro, lo hacemos.

```jsx
if (level + 1 == game.getMaxLevel()) {
  loadFinalBoss();
}

Integer nextLevel = level + 1;
if (nextLevel == game.getMaxLevel()) {
  loadFinalBoss();
}
```

**Metodos estaticos inapropiados** Los metodos estaticos no operan bajo ninguna instancia. Se debe pensar si un metodo es realmente estatico antes de declararlo como tal.
En el caso del ejemplo, deberia ser una funcion de¬†`Employee`¬†si deseamos que sea polimorfica y calcule distinto dependiendo del tipo de Employee.

```java
public class HourlyPayCalculator {
    public static Double calculatePay(Employee employee, Double overtimeRate)
}
```

**No ser precisos** Se debe tener precision sobre las decisiones que se tomen sobre el codigo. No ser vago con las decisiones.

- Si se va a calcular dinero, usar enteros y manejar el redondeo
- Si se va a tratar con concurrencia, asegurar que no hayan carreras criticas
- Si hay metodos que pueden lanzar excepciones, tratarlas.

**Darle mas peso a convenciones que a la estructura** Las convenciones son importantes pero el dise√±o del software es mas importante. No uses MVC si no es la apropiada para tu codigo.

**Navegacion Transitiva**

- Un modulo debe saber lo menos posible sobre los dem√°s
- Si A usa a B, y B usa a C, evitar¬†`a.getB().getC()`, desde A hay que acceder a B para acceder a C. Y si queremos intercalar una clase D, tenemos que modificar estos llamados agregando¬†`getD()`¬†en el medio.
- Segun la Ley de Demeter hay que escribir codigo timido, A debe ser timido y no llamar a una funcion de C a traves de B. Debe conocer lo menos posible sobre los dem√°s.
- Asi es como se forman las arquitecturas rigidas, si surge la necesidad de modificarla, ser√° muy costoso.

**Usar condicionales negativos** Siempre es mejor usar condicionales positivos. Se debe cambiar el nombre a lo que sea necesario

```java
if (!isNotValid) {
    // ...
}

if (isValid) {
    // ...
}
```

**Envidia del ambito de otra clase** Cuando una clase esta interesada en demasiada info de otra clase. Es un problema de dise√±o. Lo ideal es que los metodos de una clase esten interesadas en su propia clase, y no tenga que usar variables ni funciones de otra clase.
En el ejemplo,¬†`GameRankCalculator`¬†tiene "envidia" de la clase¬†`user`, ya que pide demasiadas cosas del mismo

```java

public class GameRankCalculator {
    public Rank calculateRank(User user) {
        Double hoursPlayed = user.getHoursPlayed();
        int gamesPlayed = user.getGamesPlayed();
        int achievements = user.getAchievements();

        Double winPercentage = gamesPlayed / user.getGamesWon();
        Double rank = hoursPlayed * gamesPlayed * achievements * winPercentage;

        return new Rank(rank);
    }
}
```

**Clases base dependen de las derivadas** Las clases base no deben saber nada de sus derivadas. En el ejemplo,¬†`PlaneGeometry`¬†no deberia tener logica asociada ni a¬†`Rectangle`¬†ni a¬†`Triangle`¬†que lo heredan, deberian encargarse ellos de sus especificaciones de clase. La clase base no deberia depender de quien la hereda.
Se recomendaria aplicar¬†`getNumberOfSides`¬†como abstracto.

```java
public class PlaneGeometry {
    public int getNumberOfSides() {
        if (this instanceof Rectangle) {
            return 4;
        }
        if (this instanceof Triangle) {
            return 3;
        }
        return 0;
    }
}

public class Rectangle extends PlaneGeometry {}
public class Triangle extends PlaneGeometry {}
```

**Ser arbitrario** Si la estructura del codigo es arbitraria, otros haran lo mismo sobre el, ensuciando mas el codigo. Las decisiones deben ser consistentes.

**No usar convenciones** Es importante seguir las normas establecidas para un lenguaje de programacion en particular, como las formas de llamar a las variables, tama√±os de lineas, etc..
Todo el equipo debe seguir las mismas normas, si no, el codigo no sera homogeneo

**Responsabilidad fuera de lugar**

- El codigo debe ser escrito en el lugar mas natural para un lector
- No escribir el codigo donde mas convenga, si no, donde se esperaria leer
- Esto puede ir acoplado al ejemplo de PI acoplado con Circle, cuando quedaria mas claro que exista en una clase de constantes matematicas llamada¬†`Math`

**Funciones que no dicen lo que hacen** Los nombres de las funciones deben ser explicativos, por ejemplo:

```
Date newDate = oldDate.add(5)
```

¬øQu√© estamos agregando ac√°? ¬øSon 5 horas, minutos, segundos, dias?

**No conocer el algoritmo** Se deben entender los algoritmos complicados, si no los entendemos, el codigo no ser√° todo lo limpio que puede ser. Si no se entiende, se debe refactorizar.

**Pasar Flags como argumento** Un flag, boolean, indica que la funcion hace mas de una cosa. Cada funcion debe hacer unicamente una cosa.

```java
private static final Double PREMIUM_DISCOUNT_FACTOR = 0.2;
private static final Double REGULAR_DISCOUNT_FACTOR = 0.1;

public Double calculateDiscount(Item item, boolean isPremium) {
  if (isPremium) {
    return item.getPrice() * PREMIUM_DISCOUNT_FACTOR;
  }
  return item.getPrice() * REGULAR_DISCOUNT_FACTOR;
}
```

**Funciones muertas ‚Äî Dead Functions** Son funciones que no se llaman nunca. Deben eliminarse, y si llegamos a necesitarlas en un futuro, se guardan en el historial de Git.

<a id="cod65"></a>

### **Single Responsibility Principle**

- Puede ser un nombre confuso. No quiere decir que un modulo debe hacer una sola cosa, si no que **un modulo debe tener una unica razon para cambiar**
- Un modulo debe ser responsable de solo un usuario o interesado del sistema
- Un modulo es una clase dentro de POO.

Hay ciertos sintomas que diagnostican el no cumplimiento de SRP

```javascript
// Clase con una √∫nica responsabilidad: gestionar la l√≥gica relacionada con el manejo de usuarios
class UserManager {
    // M√©todo para agregar un nuevo usuario a la base de datos
    addUser(user) {
        // L√≥gica para agregar un usuario a la base de datos
        console.log(`User added: ${user.name}`);
    }

    // M√©todo para enviar un correo electr√≥nico de bienvenida a un nuevo usuario
    sendWelcomeEmail(user) {
        // L√≥gica para enviar un correo electr√≥nico de bienvenida al nuevo usuario
        console.log(`Welcome email sent to: ${user.email}`);
    }

    // M√©todo para generar un informe de usuarios registrados
    generateUserReport() {
        // L√≥gica para generar un informe de usuarios registrados
        console.log("Generating user report...");
    }
}

// Clase que representa un usuario del sistema
class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}

// Uso de las clases
const userManager = new UserManager();

const newUser = new User("John", "john@example.com");
userManager.addUser(newUser); // Output: User added: John
userManager.sendWelcomeEmail(newUser); // Output: Welcome email sent to: john@example.com
userManager.generateUserReport(); // Output: Generating user report...

```

<a id="cod66"></a>

### **Open/Closed Principle**

[Volver al indice](#cod-base)

**Un artefacto de software debe estar abierto para su extension, pero cerrado para su modificacion**. Se debe poder aumentar la funcionalidad sin modificar el funcionamiento ya existente.

¬øC√≥mo se consigue?

- Separando el Software en componentes de alta cohesion.
- Que la direccion de las dependencias sea la correcta (se vera con mas detalle mas adelante).
- Se deben proteger a los componentes de alto nivel de los cambios en los componentes de bajo nivel.

```java
// Clase base para representar formas
class Shape {
    area() {
        // M√©todo para calcular el √°rea de la forma
        throw new Error("This method must be overridden");
    }
}

// Clase para representar un rect√°ngulo
class Rectangle extends Shape {
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }

    area() {
        // Sobrescribimos el m√©todo para calcular el √°rea de un rect√°ngulo
        return this.width * this.height;
    }
}

// Clase para representar un c√≠rculo
class Circle extends Shape {
    constructor(radius) {
        super();
        this.radius = radius;
    }

    area() {
        // Sobrescribimos el m√©todo para calcular el √°rea de un c√≠rculo
        return Math.PI * this.radius ** 2;
    }
}

// Uso de las clases
const rectangle = new Rectangle(4, 5);
const circle = new Circle(3);

console.log(rectangle.area()); // Output: 20
console.log(circle.area()); // Output: 28.274333882308138

```

<a id="cod67"></a>

### **Interface Segregation Principle**

[Volver al indice](#cod-base)

El Principio de Segregaci√≥n de Interfaces (ISP) establece que una clase no debe depender de interfaces que no utiliza. En otras palabras, las interfaces deben ser lo suficientemente espec√≠ficas para cada cliente, evitando que los clientes dependan de m√©todos que no necesitan.

Supongamos que tenemos una interfaz `Worker` (Trabajador) que define diferentes acciones que un trabajador puede realizar. Sin embargo, algunos tipos de trabajadores solo necesitan implementar un subconjunto de estas acciones. Aplicaremos el ISP para dividir la interfaz `Worker` en interfaces m√°s espec√≠ficas:

```javascript
// Interfaz original para un trabajador
class Worker {
    work() {}
    eat() {}
    sleep() {}
}

// Interfaz para un trabajador que solo necesita trabajar
class WorkOnlyWorker {
    work() {}
}

// Interfaz para un trabajador que solo necesita comer
class EatOnlyWorker {
    eat() {}
}

// Interfaz para un trabajador que solo necesita dormir
class SleepOnlyWorker {
    sleep() {}
}

// Clase para un programador que solo necesita trabajar
class Programmer extends WorkOnlyWorker {
    work() {
        console.log("Programming...");
    }
}

// Clase para un camarero que solo necesita trabajar y comer
class Waiter extends WorkOnlyWorker, EatOnlyWorker {
    work() {
        console.log("Taking orders...");
    }

    eat() {
        console.log("Eating during break...");
    }
}

// Uso de las clases
const programmer = new Programmer();
const waiter = new Waiter();

programmer.work(); // Output: Programming...
waiter.work(); // Output: Taking orders...
waiter.eat(); // Output: Eating during break...

```

En este ejemplo, la interfaz `Worker` se divide en interfaces m√°s espec√≠ficas (`WorkOnlyWorker`, `EatOnlyWorker` y `SleepOnlyWorker`) que contienen solo los m√©todos necesarios para cada tipo de trabajador. Las clases concretas (`Programmer` y `Waiter`) implementan las interfaces relevantes para su tipo de trabajo, evitando as√≠ la dependencia de m√©todos que no necesitan. Esto cumple con el Principio de Segregaci√≥n de Interfaces.

<a id="cod68"></a>

### **Liskov Substitution Principle**

[Volver al indice](#cod-base)

El Principio de Sustituci√≥n de Liskov (LSP) establece que los objetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar la correcci√≥n del programa. En otras palabras, si tenemos una clase base y una subclase que la extiende, deber√≠amos poder usar un objeto de la subclase en lugar de un objeto de la clase base sin cambiar el comportamiento del programa.

Supongamos que tenemos una clase `Rectangle` (Rect√°ngulo) y una subclase `Square` (Cuadrado). Seg√∫n el LSP, deber√≠amos poder usar un objeto de tipo `Square` donde se espera un objeto de tipo `Rectangle` sin alterar el comportamiento esperado del programa:

```javascript
// Clase base para representar un rect√°ngulo
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    setWidth(width) {
        this.width = width;
    }

    setHeight(height) {
        this.height = height;
    }

    area() {
        return this.width * this.height;
    }
}

// Subclase para representar un cuadrado
class Square extends Rectangle {
    constructor(side) {
        super(side, side);
    }

    setWidth(width) {
        this.width = width;
        this.height = width;
    }

    setHeight(height) {
        this.width = height;
        this.height = height;
    }
}

// Funci√≥n para calcular el √°rea de un rect√°ngulo
function calculateArea(rectangle) {
    rectangle.setWidth(5);
    rectangle.setHeight(4);
    console.log("Area:", rectangle.area());
}

// Uso de las clases
const rectangle = new Rectangle(5, 4);
const square = new Square(5);

calculateArea(rectangle); // Output: Area: 20
calculateArea(square); // Output: Area: 25

```

En este ejemplo, la clase `Square` es una subclase de `Rectangle` y sobrescribe los m√©todos `setWidth()` y `setHeight()` para asegurarse de que siempre tenga la misma anchura y altura. Aunque `Square` es una subclase de `Rectangle`, podemos usar un objeto de tipo `Square` donde se espera un objeto de tipo `Rectangle` (como en la funci√≥n `calculateArea()`) sin cambiar el comportamiento esperado del programa. Esto cumple con el Principio de Sustituci√≥n de Liskov.

---

<a id="cic66"></a>

### **¬øQue son los NFRs, Qui√©n los define y c√≥mo se priorizan?**

[Volver al indice](#cic-base-2)

Los NFRs (Non-Functional Requirements), o requisitos no funcionales, son caracter√≠sticas o atributos de un sistema que no est√°n relacionados con las funcionalidades espec√≠ficas que ofrece, sino con c√≥mo el sistema debe comportarse o funcionar. Mientras los requisitos funcionales describen lo que el sistema debe hacer, los NFRs describen las cualidades del sistema, como rendimiento, seguridad, escalabilidad, accesibilidad, entre otros.

Ejemplos de NFRs:

- Rendimiento: El sistema debe procesar 1.000 solicitudes por segundo.
- Escalabilidad: Debe poder soportar un aumento del 50% en la cantidad de usuarios sin degradar el rendimiento.
- Disponibilidad: El sistema debe estar disponible el 99,9% del tiempo.
- Seguridad: Los datos de los usuarios deben cifrarse durante el almacenamiento y la transmisi√≥n.
- Usabilidad: Debe ser accesible para personas con discapacidades seg√∫n las pautas WCAG.
- Compatibilidad: Debe funcionar en los navegadores m√°s populares y dispositivos m√≥viles.


Los NFRs (Non-Functional Requirements), o requisitos no funcionales, son caracter√≠sticas o atributos de un sistema que no est√°n relacionados con las funcionalidades espec√≠ficas que ofrece, sino con c√≥mo el sistema debe comportarse o funcionar. Mientras los requisitos funcionales describen lo que el sistema debe hacer, los NFRs describen las cualidades del sistema, como rendimiento, seguridad, escalabilidad, accesibilidad, entre otros.

Ejemplos de NFRs:
Rendimiento: El sistema debe procesar 1.000 solicitudes por segundo.
Escalabilidad: Debe poder soportar un aumento del 50% en la cantidad de usuarios sin degradar el rendimiento.
Disponibilidad: El sistema debe estar disponible el 99,9% del tiempo.
Seguridad: Los datos de los usuarios deben cifrarse durante el almacenamiento y la transmisi√≥n.
Usabilidad: Debe ser accesible para personas con discapacidades seg√∫n las pautas WCAG.
Compatibilidad: Debe funcionar en los navegadores m√°s populares y dispositivos m√≥viles.

**¬øQui√©n define los NFRs?**

Los NFRs suelen ser definidos por una combinaci√≥n de diferentes actores involucrados en el proyecto, ya que dependen de m√∫ltiples perspectivas:

- Cliente o patrocinador del proyecto: Define las expectativas generales de calidad, disponibilidad y rendimiento.
- Usuarios finales: Especifican necesidades relacionadas con usabilidad, accesibilidad y experiencia del usuario.
- Arquitectos de software: Proporcionan requisitos relacionados con escalabilidad, rendimiento, y sostenibilidad del sistema.
- Desarrolladores: Identifican necesidades t√©cnicas para garantizar la implementaci√≥n eficiente de los NFRs.
- Ingenieros de seguridad: Proponen requisitos para proteger datos y prevenir vulnerabilidades.
-Regulaciones externas o normativas: En algunos casos, los NFRs vienen definidos por est√°ndares legales, como GDPR para protecci√≥n de datos o PCI DSS para procesamiento de pagos.

**¬øC√≥mo se priorizan los NFRs?**

La priorizaci√≥n de NFRs es clave para garantizar que los recursos disponibles se utilicen de manera efectiva y que el sistema cumpla con las expectativas m√°s importantes. Algunos enfoques comunes incluyen:

- Impacto en los objetivos del negocio: Se priorizan los NFRs que afectan directamente la satisfacci√≥n del cliente o el √©xito del producto. Por ejemplo, si el sistema debe soportar ventas online, la disponibilidad y el rendimiento ser√°n cr√≠ticos.
- Riesgos asociados: Los NFRs relacionados con seguridad o cumplimiento normativo suelen tener alta prioridad porque ignorarlos puede tener consecuencias legales o de reputaci√≥n.
- Coste y viabilidad t√©cnica: Se analiza cu√°nto tiempo y esfuerzo requiere implementar un NFR. Por ejemplo, alcanzar un tiempo de respuesta de 1 segundo puede ser m√°s costoso que aceptar un l√≠mite de 2 segundos.

Metodolog√≠as de priorizaci√≥n:

- MoSCoW: Clasificar los NFRs en Must Have (imprescindibles), Should Have (deseables), Could Have (opcionales) y Won‚Äôt Have (no necesarios ahora).
- Kano Model: Identificar cu√°les generan mayor satisfacci√≥n en los usuarios.
- Colaboraci√≥n y negociaci√≥n: Los equipos deben trabajar junto con los stakeholders para balancear los NFRs con los requisitos funcionales, asegurando que no haya conflictos en las prioridades.